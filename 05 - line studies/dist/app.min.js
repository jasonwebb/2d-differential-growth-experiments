"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof2(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function () {
  function r(e, n, t) {
    function o(i, f) {
      if (!n[i]) {
        if (!e[i]) {
          var c = "function" == typeof require && require;
          if (!f && c) return c(i, !0);
          if (u) return u(i, !0);
          var a = new Error("Cannot find module '" + i + "'");
          throw a.code = "MODULE_NOT_FOUND", a;
        }

        var p = n[i] = {
          exports: {}
        };
        e[i][0].call(p.exports, function (r) {
          var n = e[i][1][r];
          return o(n || r);
        }, p, p.exports, r, e, n, t);
      }

      return n[i].exports;
    }

    for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
      o(t[i]);
    }

    return o;
  }

  return r;
})()({
  1: [function (require, module, exports) {
    module.exports = {
      SeedRadius: 100,
      MinDistance: 1,
      MaxDistance: 5,
      RepulsionRadius: 10,
      MaxVelocity: .1,
      AttractionForce: .2,
      RepulsionForce: .6,
      AlignmentForce: .55,
      ScreenPadding: 20,
      MaxNodes: 10000,
      NodeInjectionInterval: 100,
      DrawNodes: false,
      TraceMode: false,
      InvertedColors: true,
      DebugMode: false,
      FillMode: false,
      BrownianMotionRange: .01,
      UseBrownianMotion: true
    };
  }, {}],
  2: [function (require, module, exports) {
    var Node = require('../../core/Node'),
        Path = require('../../core/Path'),
        World = require('../../core/World'),
        Settings = require('./Settings'),
        MIDIControl = require('../../core/MIDIControl');

    var world;
    var HORIZONTAL = 0,
        VERTICAL = 1,
        ANGLED = 2,
        RADIAL = 3,
        OPPOSING_ARCS = 4,
        NUCLEATION = 5;
    var currentLineType = NUCLEATION;
    /*
    =============================================================================
      Main sketch
    =============================================================================
    */

    var sketch = function sketch(p5) {
      // Setup -------------------------------------------------------------
      p5.setup = function () {
        p5.createCanvas(window.innerWidth, window.innerHeight);
        p5.colorMode(p5.HSB, 255);
        p5.rectMode(p5.CENTER); // Set up and start the simulation

        world = new World(p5, Settings); // Create random paths

        restartWorld(); // Set up MIDI controller as input

        this.midi = new MIDIControl(); // Process MIDI 'noteon' events

        document.addEventListener('noteon', function (e) {
          console.log(e.detail);
        }); // Process MIDI 'controlchange' events

        document.addEventListener('controlchange', function (e) {
          console.log(e.detail);
        });
      }; // Draw ---------------------------------------------------------------


      p5.draw = function () {
        world.iterate();
        world.draw(); // Draw canvas bounds for alignment with video recording software

        p5.noFill();

        if (Settings.InvertedColors) {
          p5.stroke(255);
        } else {
          p5.stroke(0);
        }

        p5.rect(window.innerWidth / 2, window.innerHeight / 2, 900 - 100, 900 - 100);
      }; // Create a grid of lines as Paths consisting of two Nodes each with configurable deltas in position


      function createLines(rows, columns, rowSpacing, columnSpacing, xDelta, yDelta) {
        var totalWidth = columnSpacing * columns;
        var totalHeight = rowSpacing * rows;

        for (var i = 0; i < rows; i++) {
          // rows
          for (var j = 0; j < columns; j++) {
            // columns
            var nodes = []; // Lower left node

            nodes.push(new Node(p5, j * columnSpacing + window.innerWidth / 2 - totalWidth / 2, i * rowSpacing + window.innerHeight / 2 - totalHeight / 2 + rowSpacing / 2, Settings)); // Upper right node

            nodes.push(new Node(p5, j * columnSpacing + window.innerWidth / 2 + xDelta - totalWidth / 2, i * rowSpacing + window.innerHeight / 2 + yDelta - totalHeight / 2 + rowSpacing / 2, Settings)); // Construct path and add to world

            world.addPath(new Path(p5, nodes, Settings));
          }
        }
      } // Horizontal lines only have deltas along X axis


      function createHorizontalLines(rows, columns) {
        createLines(rows, columns, 20, 45, 30, 0);
      } // Vertical lines only have deltas along Y axis


      function createVerticalLines(rows, columns) {
        createLines(rows, columns, 38, 20, 0, 30);
      } // Angled lines have deltas along both X and Y axes


      function createAngledLines(rows, columns) {
        createLines(rows, columns, 38, 20, -30, 30);
      } // Create an arc composed of lines


      function createArcLines(centerX, centerY, degreesStart, degreesEnd, innerRadius, linesPerArc, lineLength) {
        var angleDelta = (degreesEnd - degreesStart) / linesPerArc;
        var outerRadius = innerRadius + lineLength;

        for (var i = degreesStart; i < degreesEnd; i += angleDelta) {
          var nodes = []; // Innermost Node

          nodes[0] = new Node(p5, innerRadius * Math.cos(i * (Math.PI / 180)), innerRadius * Math.sin(i * (Math.PI / 180)), Settings); // Outermost Node

          nodes[1] = new Node(p5, outerRadius * Math.cos(i * (Math.PI / 180)), outerRadius * Math.sin(i * (Math.PI / 180)), Settings);
          var path = new Path(p5, nodes, Settings);
          path.moveTo(centerX, centerY);
          world.addPath(path);
        }
      } // Create two arcs of lines in opposing corners of the canvas


      function createOpposingArcs() {
        createArcLines(window.innerWidth / 2 - 900 / 2 + 100, window.innerHeight / 2 + 900 / 2 - 75, 270, 360, 375, 66, 100);
        createArcLines(window.innerWidth / 2 + 900 / 2 - 100, window.innerHeight / 2 - 900 / 2 + 75, 90, 180, 375, 60, 100);
      } // Create a full ring of lines


      function createLineRing() {
        createArcLines(window.innerWidth / 2, window.innerHeight / 2, 0, 360, 75, 60, 50);
      } // Create radial arc arrangements at multiple spots


      function createNucleationSites() {
        var sites = [{
          x: -200,
          y: -210,
          ds: 0,
          de: 360,
          r: 25,
          lpa: 55,
          ll: 100
        }, {
          x: 60,
          y: -100,
          ds: 0,
          de: 360,
          r: 25,
          lpa: 30,
          ll: 35
        }, {
          x: -80,
          y: -20,
          ds: 0,
          de: 360,
          r: 50,
          lpa: 45,
          ll: 25
        }, {
          x: 150,
          y: 150,
          ds: 0,
          de: 360,
          r: 100,
          lpa: 60,
          ll: 70
        }, {
          x: -40,
          y: -150,
          ds: 0,
          de: 360,
          r: 15,
          lpa: 18,
          ll: 10
        }, {
          x: -400,
          y: 400,
          ds: 270,
          de: 360,
          r: 400,
          lpa: 60,
          ll: 30
        }, {
          x: -400,
          y: 400,
          ds: 270,
          de: 360,
          r: 350,
          lpa: 15,
          ll: 20
        }, {
          x: -400,
          y: 400,
          ds: 270,
          de: 360,
          r: 300,
          lpa: 7,
          ll: 40
        }, {
          x: -400,
          y: 400,
          ds: 270,
          de: 360,
          r: 200,
          lpa: 30,
          ll: 75
        }, {
          x: 125,
          y: -400,
          ds: 0,
          de: 180,
          r: 175,
          lpa: 45,
          ll: 30
        }, {
          x: 275,
          y: -110,
          ds: 0,
          de: 360,
          r: 75,
          lpa: 45,
          ll: 15
        }];

        for (var i = 0; i < sites.length; i++) {
          createArcLines(window.innerWidth / 2 + sites[i].x, window.innerHeight / 2 + sites[i].y, sites[i].ds, sites[i].de, sites[i].r, sites[i].lpa, sites[i].ll);
        }
      } // Restart the simulation with the selected path type -------------------


      function restartWorld() {
        world.clearPaths(); // Create a field of lines

        switch (currentLineType) {
          case HORIZONTAL:
            createHorizontalLines(30, 10);
            break;

          case VERTICAL:
            createVerticalLines(10, 30);
            break;

          case ANGLED:
            createAngledLines(15, 20);
            break;

          case RADIAL:
            createLineRing();
            break;

          case OPPOSING_ARCS:
            createOpposingArcs();
            break;

          case NUCLEATION:
            createNucleationSites();
            break;
        } // Draw the first frame, then pause


        world.drawBackground();
        world.draw();
        world.pause(); // Restart simulation after 1s

        setTimeout(function () {// world.unpause();
        }, 1000);
      }
      /*
      =============================================================================
        Key handler
      =============================================================================
      */


      p5.keyReleased = function () {
        switch (p5.key) {
          // Switch to horizontal lines with '1'
          case '1':
            currentLineType = HORIZONTAL;
            restartWorld();
            break;
          // Switch to vertical lines with '2'

          case '2':
            currentLineType = VERTICAL;
            restartWorld();
            break;
          // Switch to angled lines with '3'

          case '3':
            currentLineType = ANGLED;
            restartWorld();
            break;
          // Switch to radial arrangement of lines with '4'

          case '4':
            currentLineType = RADIAL;
            restartWorld();
            break;
          // Switch to dual radial arcs with '5'

          case '5':
            currentLineType = OPPOSING_ARCS;
            restartWorld();
            break;
          // Switch to nucleation sites of arc lines with '6'

          case '6':
            currentLineType = NUCLEATION;
            restartWorld();
            break;
          // Toggle trace mode with 't'

          case 't':
            world.toggleTraceMode();
            break;
          // Toggle drawing of nodes with 'n'

          case 'n':
            world.toggleDrawNodes();
            break;
          // Reset simulation with current parameters with 'r'

          case 'r':
            restartWorld();
            break;
          // Toggle pause with Space

          case ' ':
            world.paused = !world.paused;
            var total = 0;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = world.paths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var path = _step2.value;
                total += path.nodes.length;
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }

            console.log(total);
            break;
          // Invert colors with 'i'

          case 'i':
            world.toggleInvertedColors();
            break;
          // Toggle debug mode with 'd'

          case 'd':
            world.toggleDebugMode();
            break;
          // Toggle fill for all shapes with 'f'

          case 'f':
            world.toggleFillMode();
            break;
          // Export SVG with 's'

          case 's':
            world.export();
            break;
        }
      };
    }; // Launch the sketch using p5js in instantiated mode


    new p5(sketch);
  }, {
    "../../core/MIDIControl": 4,
    "../../core/Node": 5,
    "../../core/Path": 6,
    "../../core/World": 7,
    "./Settings": 1
  }],
  3: [function (require, module, exports) {
    module.exports = {
      MinDistance: 20,
      // injection, attraction
      MaxDistance: 30,
      // split
      RepulsionRadius: 20,
      MaxVelocity: .1,
      Acceleration: .1,
      AttractionForce: .001,
      RepulsionForce: 500,
      AlignmentForce: .001,
      ScreenPadding: 20,
      MaxNodes: 3000,
      NodeInjectionInterval: 100,
      DrawNodes: false,
      TraceMode: false,
      UseBrownianMotion: false,
      BrownianMotionRange: 0.01
    };
  }, {}],
  4: [function (require, module, exports) {
    var WebMidi = require('./node_modules/webmidi');

    var MIDIControl = function MIDIControl() {
      _classCallCheck(this, MIDIControl);

      WebMidi.enable(function (err) {
        if (err) {
          console.log(err);
        } else {
          // Akai LPD8 has 8 pads and 8 knobs
          this.lpd8 = WebMidi.getInputByName('Akai LPD8 Wireless');

          if (this.lpd8) {
            // Pads
            this.lpd8.addListener('noteon', 'all', function (e) {
              var midiEvent = new CustomEvent('noteon', {
                detail: {
                  note: e.note.number,
                  velocity: e.velocity
                }
              }); // Bubble up a custom event available to p5js sketch

              document.dispatchEvent(midiEvent);
            }); // Knobs

            this.lpd8.addListener('controlchange', 'all', function (e) {
              var midiEvent = new CustomEvent('controlchange', {
                detail: {
                  controller: e.controller.number,
                  value: e.value
                }
              }); // Bubble up a custom event available to p5js sketch

              document.dispatchEvent(midiEvent);
            });
          }
        }
      });
    };

    module.exports = MIDIControl;
  }, {
    "./node_modules/webmidi": 17
  }],
  5: [function (require, module, exports) {
    var Vec2 = require('./node_modules/vec2'),
        Defaults = require('./Defaults');
    /*
    =============================================================================
      Node class
    
      A Node is a single point on the canvas whose only job is to manage
      it's position and movement towards new position. 
    =============================================================================
    */


    var Node =
    /*#__PURE__*/
    function (_Vec) {
      _inherits(Node, _Vec);

      function Node(p5, x, y) {
        var _this;

        var settings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Defaults;
        var isFixed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

        _classCallCheck(this, Node);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(Node).call(this, x, y));
        _this.p5 = p5;
        _this.isFixed = isFixed;
        _this.settings = settings;
        _this.velocity = 0;
        _this.nextPosition = new Vec2(x, y);
        return _this;
      }

      _createClass(Node, [{
        key: "iterate",
        value: function iterate() {
          if (!this.isFixed) {
            this.x = this.p5.lerp(this.x, this.nextPosition.x, this.settings.MaxVelocity);
            this.y = this.p5.lerp(this.y, this.nextPosition.y, this.settings.MaxVelocity);
          }
        }
      }, {
        key: "draw",
        value: function draw() {
          if (this.isFixed) {
            this.p5.ellipse(this.x, this.y, 20);
          } else {
            this.p5.ellipse(this.x, this.y, 5);
          }
        }
      }]);

      return Node;
    }(Vec2);

    module.exports = Node;
  }, {
    "./Defaults": 3,
    "./node_modules/vec2": 16
  }],
  6: [function (require, module, exports) {
    var knn = require('./node_modules/rbush-knn');

    Node = require('./Node');
    /*
    =============================================================================
      Path class
    
      A Path manages a set of Nodes in a continuous, ordered
      data structure (an Array). 
    =============================================================================
    */

    var Path =
    /*#__PURE__*/
    function () {
      function Path(p5, nodes) {
        var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Defaults;
        var isClosed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var fillColor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
          h: 0,
          s: 0,
          b: 0,
          a: 255
        };
        var strokeColor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
          h: 0,
          s: 0,
          b: 0,
          a: 255
        };
        var invertedFillColor = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {
          h: 0,
          s: 0,
          b: 255,
          a: 255
        };
        var invertedStrokeColor = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {
          h: 0,
          s: 0,
          b: 255,
          a: 255
        };

        _classCallCheck(this, Path);

        this.p5 = p5;
        this.nodes = nodes;
        this.isClosed = isClosed;
        this.settings = settings;
        this.injectionMode = "RANDOM";
        this.lastNodeInjectTime = 0;
        this.drawNodes = this.settings.DrawNodes;
        this.invertedColors = this.settings.InvertedColors;
        this.traceMode = this.settings.TraceMode;
        this.debugMode = this.settings.DebugMode;
        this.fillMode = this.settings.FillMode;
        this.useBrownianMotion = this.settings.UseBrownianMotion;
        this.fillColor = fillColor;
        this.strokeColor = strokeColor;
        this.invertedFillColor = invertedFillColor;
        this.invertedStrokeColor = invertedStrokeColor;
        this.currentFillColor = this.fillColor;
        this.currentStrokeColor = this.strokeColor;

        if (this.invertedColors) {
          this.currentFillColor = this.invertedFillColor;
          this.currentStrokeColor = this.invertedStrokeColor;
        }
      } //------------------------------------------------------------------
      //  Iterate
      //  =======
      //  Run a single 'tick' of the simulation 
      //-----------------------------------------------------------------


      _createClass(Path, [{
        key: "iterate",
        value: function iterate(tree) {
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = this.nodes.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _step3$value = _slicedToArray(_step3.value, 2),
                  index = _step3$value[0],
                  node = _step3$value[1];

              // Apply Brownian motion to realistically 'jiggle' nodes
              if (this.useBrownianMotion) {
                this.applyBrownianMotion(index);
              } // Move towards neighbors (attraction), if there is space to move


              this.applyAttraction(index); // Move away from any nodes that are too close (repulsion)

              this.applyRepulsion(index, tree); // Align with neighbors

              this.applyAlignment(index); // Constrain to the screen

              this.avoidWalls(index); // Move towards next position

              node.iterate();
            } // Split any edges that have become too long

          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          this.splitEdges(); // Remove any nodes that are too close to other nodes

          this.pruneNodes(); // Inject a new node to introduce asymmetry every so often

          if (this.p5.millis() - this.lastNodeInjectTime >= this.settings.NodeInjectionInterval && this.nodes.length < this.settings.MaxNodes) {
            this.injectNode();
            this.lastNodeInjectTime = this.p5.millis();
          }
        } //---------------------------------------------------------------------
        //  Brownian motion
        //  ===============
        //  Simulate the random

      }, {
        key: "applyBrownianMotion",
        value: function applyBrownianMotion(index) {
          this.nodes[index].x += this.p5.random(-this.settings.BrownianMotionRange / 2, this.settings.BrownianMotionRange / 2);
          this.nodes[index].y += this.p5.random(-this.settings.BrownianMotionRange / 2, this.settings.BrownianMotionRange / 2);
        } //---------------------------------------------------------------------
        //  Attraction
        //  ==========
        //  Move the referenced node closer to it's connected neighbor nodes
        //---------------------------------------------------------------------

      }, {
        key: "applyAttraction",
        value: function applyAttraction(index) {
          var distance;
          var connectedNodes = this.getConnectedNodes(index); // Move towards next node, if there is one

          if (connectedNodes.nextNode != undefined && connectedNodes.nextNode instanceof Node && !this.nodes[index].isFixed) {
            distance = this.nodes[index].distance(connectedNodes.nextNode);

            if (distance > this.settings.MinDistance) {
              this.nodes[index].nextPosition.x = this.p5.lerp(this.nodes[index].nextPosition.x, connectedNodes.nextNode.x, this.settings.AttractionForce);
              this.nodes[index].nextPosition.y = this.p5.lerp(this.nodes[index].nextPosition.y, connectedNodes.nextNode.y, this.settings.AttractionForce);
            }
          } // Move towards previous node, if there is one


          if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && !this.nodes[index].isFixed) {
            distance = this.nodes[index].distance(connectedNodes.previousNode);

            if (distance > this.settings.MinDistance) {
              this.nodes[index].nextPosition.x = this.p5.lerp(this.nodes[index].nextPosition.x, connectedNodes.previousNode.x, this.settings.AttractionForce);
              this.nodes[index].nextPosition.y = this.p5.lerp(this.nodes[index].nextPosition.y, connectedNodes.previousNode.y, this.settings.AttractionForce);
            }
          }
        } //------------------------------------------------------------------------
        //  Repulsion
        //  =========
        //  Move the referenced node away from all nearby nodes within a radius
        //------------------------------------------------------------------------

      }, {
        key: "applyRepulsion",
        value: function applyRepulsion(index, tree) {
          // Perform knn search to find all neighbors within certain radius
          var neighbors = knn(tree, this.nodes[index].x, this.nodes[index].y, undefined, undefined, this.settings.RepulsionRadius * this.settings.RepulsionRadius); // radius must be squared as per https://github.com/mourner/rbush-knn/issues/13
          // Move this node away from all nearby neighbors
          // TODO: Make this proportional to distance?

          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = neighbors[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var node = _step4.value;
              this.nodes[index].nextPosition.x = this.p5.lerp(this.nodes[index].x, node.x, -this.settings.RepulsionForce);
              this.nodes[index].nextPosition.y = this.p5.lerp(this.nodes[index].y, node.y, -this.settings.RepulsionForce);
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        } //-------------------------------------------------------------
        //  Alignment
        //  =========
        //  Move the referenced node closer to the midpoint of it's
        //  neighbor connected nodes to minimize curvature
        //-------------------------------------------------------------

      }, {
        key: "applyAlignment",
        value: function applyAlignment(index) {
          var connectedNodes = this.getConnectedNodes(index);

          if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && connectedNodes.nextNode != undefined && connectedNodes.nextNode instanceof Node && !this.nodes[index].isFixed) {
            // Find the midpoint between the neighbors of this node
            var midpoint = this.getMidpointNode(connectedNodes.previousNode, connectedNodes.nextNode); // Move this point towards this midpoint

            this.nodes[index].nextPosition.x = this.p5.lerp(this.nodes[index].nextPosition.x, midpoint.x, this.settings.AlignmentForce);
            this.nodes[index].nextPosition.y = this.p5.lerp(this.nodes[index].nextPosition.y, midpoint.y, this.settings.AlignmentForce);
          }
        } //--------------------------------------------------------------
        //  Split edges
        //  ===========
        //  Search for long edges, then inject a new node when found
        //--------------------------------------------------------------

      }, {
        key: "splitEdges",
        value: function splitEdges() {
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = this.nodes.entries()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var _step5$value = _slicedToArray(_step5.value, 2),
                  index = _step5$value[0],
                  node = _step5$value[1];

              var connectedNodes = this.getConnectedNodes(index);

              if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && node.distance(connectedNodes.previousNode) >= this.settings.MaxDistance && this.nodes.length < this.settings.MaxNodes) {
                var midpointNode = this.getMidpointNode(node, connectedNodes.previousNode); // Inject the new midpoint node into the global list

                if (index == 0) {
                  this.nodes.splice(this.nodes.length, 0, midpointNode);
                } else {
                  this.nodes.splice(index, 0, midpointNode);
                }
              }
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        } //------------------------------------------------------------
        //  Prune nodes
        //  ===========
        //  Remove nodes when they are too close to their neighbors
        //------------------------------------------------------------

      }, {
        key: "pruneNodes",
        value: function pruneNodes() {
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = this.nodes.entries()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var _step6$value = _slicedToArray(_step6.value, 2),
                  index = _step6$value[0],
                  node = _step6$value[1];

              var connectedNodes = this.getConnectedNodes(index);

              if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && node.distance(connectedNodes.previousNode) < this.settings.MinDistance) {
                if (index == 0) {
                  if (!this.nodes[this.nodes.length - 1].isFixed) {
                    this.nodes.splice(this.nodes.length - 1, 1);
                  }
                } else {
                  if (!this.nodes[index - 1].isFixed) {
                    this.nodes.splice(index - 1, 1);
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
                _iterator6.return();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }
        } //---------------------------------------------------
        //  Inject a node
        //  =============
        //  Create a new node between two existing nodes
        //---------------------------------------------------

      }, {
        key: "injectNode",
        value: function injectNode() {
          switch (this.injectionMode) {
            case "RANDOM":
              this.injectRandomNode();
              break;

            case "CURVATURE":
              this.injectNodeByCurvature();
              break;
          }
        } // Inject a new node in a random location, if there is space for it

      }, {
        key: "injectRandomNode",
        value: function injectRandomNode() {
          // Choose two connected nodes at random
          var index = parseInt(this.p5.random(1, this.nodes.length));
          var connectedNodes = this.getConnectedNodes(index);

          if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && connectedNodes.nextNode != undefined && connectedNodes.nextNode instanceof Node && this.nodes[index].distance(connectedNodes.previousNode) > this.settings.MinDistance) {
            // Create a new node in the middle
            var midpointNode = this.getMidpointNode(this.nodes[index], connectedNodes.previousNode); // Splice new node into array

            this.nodes.splice(index, 0, midpointNode);
          }
        } // Inject new node nodes when curvature is too high
        // - When the angle between connected nodes is too high, remove
        //   the middle node and replace it with two nodes at the respective
        //   midpoints of the previous two lines. This "truncates" or "chamfers"
        //   the pointy node into two flatter nodes.

      }, {
        key: "injectNodeByCurvature",
        value: function injectNodeByCurvature() {
          console.log('test');
          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = undefined;

          try {
            for (var _iterator7 = this.nodes.entries()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var _step7$value = _slicedToArray(_step7.value, 2),
                  index = _step7$value[0],
                  node = _step7$value[1];

              var connectedNodes = this.getConnectedNodes(index); // Find angle between adjacent nodes

              var a = node.distance(connectedNodes.previousNode);
              var b = node.distance(connectedNodes.nextNode);
              var angle = Math.atan(a / b) * 180 / Math.PI; // If angle is below a certain angle (high curvature), replace the current node with two nodes

              if (angle < 30) {
                console.log(index);
                var previousMidpointNode = this.getMidpointNode(node, connectedNodes.previousNode);
                var nextMidpointNode = this.getMidpointNode(node, connectedNodes.nextNode);
                console.log(previousMidpointNode);
                console.log(nextMidpointNode);
                this.p5.noLoop(); // console.log(previousMidpointNode);
                // console.log(nextMidpointNode);
                // Replace this node with the two new nodes

                if (index == 0) {
                  this.nodes.splice(this.nodes.length - 1, 0, previousMidpointNode);
                  this.nodes.splice(0, 1, nextMidpointNode);
                } else {
                  // console.log(index);
                  // console.log(this.nodes);
                  this.nodes.splice(index, 1, previousMidpointNode, nextMidpointNode); // console.log(this.nodes);
                  // this.p5.noLoop();
                }
              }
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
                _iterator7.return();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }
        } //------------------------------------------------------------------
        //  Avoid walls
        //  ===========
        //  Clamp node position to the window to prevent "runaway" growth  
        //------------------------------------------------------------------

      }, {
        key: "avoidWalls",
        value: function avoidWalls(index) {
          this.nodes[index].x = this.p5.constrain(this.nodes[index].x, 0, window.innerWidth);
          this.nodes[index].y = this.p5.constrain(this.nodes[index].y, 0, window.innerHeight);
        } //------------------------------------------------------------
        //  Get connected nodes
        //  ===================
        //  For a given node, find and return the nodes that come 
        //  immediately before and after it.
        //------------------------------------------------------------

      }, {
        key: "getConnectedNodes",
        value: function getConnectedNodes(index) {
          var previousNode, nextNode; // Find previous node, if there is one

          if (index == 0 && this.isClosed) {
            previousNode = this.nodes[this.nodes.length - 1];
          } else if (index >= 1) {
            previousNode = this.nodes[index - 1];
          } // Find next node, if there is one


          if (index == this.nodes.length - 1 && this.isClosed) {
            nextNode = this.nodes[0];
          } else if (index <= this.nodes.length - 1) {
            nextNode = this.nodes[index + 1];
          }

          return {
            previousNode: previousNode,
            nextNode: nextNode
          };
        } //------------------------------------------------------------
        //  Get midpoint node
        //  =================
        //  Create and return a node exactly halfway between the
        //  two provided nodes.
        //------------------------------------------------------------

      }, {
        key: "getMidpointNode",
        value: function getMidpointNode(node1, node2) {
          var fixed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          return new Node(this.p5, (node1.x + node2.x) / 2, (node1.y + node2.y) / 2, this.settings, fixed);
        } //--------------------------------------------
        //  Draw
        //  ====
        //  Draw all nodes and edges to the canvas
        //--------------------------------------------

      }, {
        key: "draw",
        value: function draw() {
          // Set shape fill 
          if (this.fillMode) {
            this.p5.fill(this.currentFillColor.h, this.currentFillColor.s, this.currentFillColor.b, this.currentFillColor.a);
          } else {
            this.p5.noFill();
          } // Set stroke color


          this.p5.stroke(this.currentStrokeColor.h, this.currentStrokeColor.s, this.currentStrokeColor.b, this.currentStrokeColor.a); // Begin capturing vertices

          if (!this.debugMode) {
            this.p5.beginShape();
          } // Create vertices or lines (if debug mode)


          for (var i = 0; i < this.nodes.length; i++) {
            if (!this.debugMode) {
              this.p5.vertex(this.nodes[i].x, this.nodes[i].y);
            } else {
              // In debug mode each line has a unique stroke color, which isn't possible with begin/endShape(). Instead we'll use line()
              if (i > 0) {
                if (!this.traceMode) {
                  this.p5.stroke(this.p5.map(i, 0, this.nodes.length - 1, 0, 255, true), 255, 255, 255);
                } else {
                  this.p5.stroke(this.p5.map(i, 0, this.nodes.length - 1, 0, 255, true), 255, 255, 2);
                }

                this.p5.line(this.nodes[i - 1].x, this.nodes[i - 1].y, this.nodes[i].x, this.nodes[i].y);
              }
            }
          } // For closed paths, connect the last and first nodes


          if (this.isClosed) {
            if (!this.debugMode) {
              this.p5.vertex(this.nodes[0].x, this.nodes[0].y);
            } else {
              this.p5.line(this.nodes[this.nodes.length - 1].x, this.nodes[this.nodes.length - 1].y, this.nodes[0].x, this.nodes[0].y);
            }
          } // Stop capturing vertices


          if (!this.debugMode) {
            this.p5.endShape();
          } // Draw all nodes


          if (this.drawNodes) {
            this.p5.noStroke();

            if (!this.invertedColors) {
              this.p5.fill(0);
            } else {
              this.p5.fill(255);
            }

            var _iteratorNormalCompletion8 = true;
            var _didIteratorError8 = false;
            var _iteratorError8 = undefined;

            try {
              for (var _iterator8 = this.nodes.entries()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var _step8$value = _slicedToArray(_step8.value, 2),
                    index = _step8$value[0],
                    node = _step8$value[1];

                if (this.debugMode) {
                  this.p5.fill(this.p5.map(index, 0, this.nodes.length - 1, 0, 255, true), 255, 255, 255);
                }

                node.draw();
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
          }
        } // Translate this path by the provided offsets

      }, {
        key: "moveTo",
        value: function moveTo(xOffset, yOffset) {
          var _iteratorNormalCompletion9 = true;
          var _didIteratorError9 = false;
          var _iteratorError9 = undefined;

          try {
            for (var _iterator9 = this.nodes[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
              var node = _step9.value;
              node.x += xOffset;
              node.y += yOffset;
            }
          } catch (err) {
            _didIteratorError9 = true;
            _iteratorError9 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
                _iterator9.return();
              }
            } finally {
              if (_didIteratorError9) {
                throw _iteratorError9;
              }
            }
          }
        } // Scale (multiply) all Nodes by the provided factor

      }, {
        key: "scale",
        value: function scale(factor) {
          var _iteratorNormalCompletion10 = true;
          var _didIteratorError10 = false;
          var _iteratorError10 = undefined;

          try {
            for (var _iterator10 = this.nodes[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
              var node = _step10.value;
              node.x *= factor;
              node.y *= factor;
            }
          } catch (err) {
            _didIteratorError10 = true;
            _iteratorError10 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
                _iterator10.return();
              }
            } finally {
              if (_didIteratorError10) {
                throw _iteratorError10;
              }
            }
          }
        } // Add a new node from outside this class

      }, {
        key: "addNode",
        value: function addNode(node) {
          this.nodes.push(node);
        } // Getters ------------------------------------

      }, {
        key: "getTraceMode",
        value: function getTraceMode() {
          return this.traceMode;
        }
      }, {
        key: "getInvertedColors",
        value: function getInvertedColors() {
          return this.invertedColors;
        } // Setters ------------------------------------

      }, {
        key: "setTraceMode",
        value: function setTraceMode(state) {
          this.traceMode = state;

          if (!this.traceMode) {
            this.currentFillColor.a = 255;
            this.currentStrokeColor.a = 255;
          } else {
            this.currentFillColor.a = 2;
            this.currentStrokeColor.a = 2;
          }
        }
      }, {
        key: "setInvertedColors",
        value: function setInvertedColors(state) {
          this.invertedColors = state;

          if (!this.invertedColors) {
            this.currentFillColor = this.fillColor;
            this.currentStrokeColor = this.strokeColor;
          } else {
            this.currentFillColor = this.invertedFillColor;
            this.currentStrokeColor = this.invertedStrokeColor;
          } // Reapply the current trace mode state to make sure opacity is adjusted when colors are inverted


          this.setTraceMode(this.traceMode);
        } // Toggles ------------------------------------

      }, {
        key: "toggleTraceMode",
        value: function toggleTraceMode() {
          this.setTraceMode(!this.getTraceMode());
        }
      }, {
        key: "toggleInvertedColors",
        value: function toggleInvertedColors() {
          this.setInvertedColors(!this.getInvertedColors());
        }
      }]);

      return Path;
    }();

    module.exports = Path;
  }, {
    "./Node": 5,
    "./node_modules/rbush-knn": 9
  }],
  7: [function (require, module, exports) {
    var rbush = require('./node_modules/rbush'),
        toPath = require('./node_modules/svg-points/').toPath,
        Defaults = require('./Defaults');
    /*
    =============================================================================
      World class
    
      A World manages a set of Paths and provides some global control
      mechanisms, such as pausing the simulation.
    =============================================================================
    */


    var World =
    /*#__PURE__*/
    function () {
      function World(p5) {
        var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Defaults;
        var paths = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

        _classCallCheck(this, World);

        this.p5 = p5;
        this.paths = paths;
        this.paused = false;
        this.settings = settings;
        this.traceMode = this.settings.TraceMode;
        this.drawNodes = this.settings.DrawNodes;
        this.debugMode = this.settings.DebugMode;
        this.invertedColors = this.settings.InvertedColors;
        this.fillMode = this.settings.FillMode;
        this.useBrownianMotion = this.settings.UseBrownianMotion;
        this.tree = rbush(9, ['.x', '.y', '.x', '.y']); // use custom accessor strings per https://github.com/mourner/rbush#data-format

        this.buildTree();
      } // Run a single tick for all paths -----------------


      _createClass(World, [{
        key: "iterate",
        value: function iterate() {
          this.buildTree();

          if (this.paths != undefined && this.paths instanceof Array && this.paths.length > 0 && !this.paused) {
            var _iteratorNormalCompletion11 = true;
            var _didIteratorError11 = false;
            var _iteratorError11 = undefined;

            try {
              for (var _iterator11 = this.paths[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                var path = _step11.value;
                path.iterate(this.tree);
              }
            } catch (err) {
              _didIteratorError11 = true;
              _iteratorError11 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
                  _iterator11.return();
                }
              } finally {
                if (_didIteratorError11) {
                  throw _iteratorError11;
                }
              }
            }
          }
        } // Draw all paths ----------------------------------

      }, {
        key: "draw",
        value: function draw() {
          if (!this.paused) {
            if (!this.traceMode) {
              this.drawBackground();
            }

            var _iteratorNormalCompletion12 = true;
            var _didIteratorError12 = false;
            var _iteratorError12 = undefined;

            try {
              for (var _iterator12 = this.paths[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                var path = _step12.value;
                path.draw();
              }
            } catch (err) {
              _didIteratorError12 = true;
              _iteratorError12 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                  _iterator12.return();
                }
              } finally {
                if (_didIteratorError12) {
                  throw _iteratorError12;
                }
              }
            }
          }
        } // Draw the background -----------------------------

      }, {
        key: "drawBackground",
        value: function drawBackground() {
          if (!this.invertedColors) {
            this.p5.background(255);
          } else {
            this.p5.background(0);
          }
        } // Build an R-tree spatial index with all paths ----

      }, {
        key: "buildTree",
        value: function buildTree() {
          this.tree.clear();
          var _iteratorNormalCompletion13 = true;
          var _didIteratorError13 = false;
          var _iteratorError13 = undefined;

          try {
            for (var _iterator13 = this.paths[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
              var path = _step13.value;
              this.tree.load(path.nodes);
            }
          } catch (err) {
            _didIteratorError13 = true;
            _iteratorError13 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
                _iterator13.return();
              }
            } finally {
              if (_didIteratorError13) {
                throw _iteratorError13;
              }
            }
          }
        } // Add a new path to the world ---------------------

      }, {
        key: "addPath",
        value: function addPath(path) {
          // Cascade all current World settings to new path
          path.drawNodes = this.drawNodes;
          path.debugMode = this.debugMode;
          path.fillMode = this.fillMode;
          path.useBrownianMotion = this.useBrownianMotion;
          path.setInvertedColors(this.invertedColors);
          path.setTraceMode(this.traceMode);
          this.paths.push(path);
        }
      }, {
        key: "addPaths",
        value: function addPaths(paths) {
          var _iteratorNormalCompletion14 = true;
          var _didIteratorError14 = false;
          var _iteratorError14 = undefined;

          try {
            for (var _iterator14 = paths[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
              var path = _step14.value;
              this.addPath(path);
            }
          } catch (err) {
            _didIteratorError14 = true;
            _iteratorError14 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
                _iterator14.return();
              }
            } finally {
              if (_didIteratorError14) {
                throw _iteratorError14;
              }
            }
          }
        }
      }, {
        key: "export",
        value: function _export() {
          var svg = document.createElement('svg');
          var _iteratorNormalCompletion15 = true;
          var _didIteratorError15 = false;
          var _iteratorError15 = undefined;

          try {
            for (var _iterator15 = this.paths[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
              var path = _step15.value;
              var pointsString = '';
              var _iteratorNormalCompletion16 = true;
              var _didIteratorError16 = false;
              var _iteratorError16 = undefined;

              try {
                for (var _iterator16 = path.nodes.entries()[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
                  var _step16$value = _slicedToArray(_step16.value, 2),
                      index = _step16$value[0],
                      node = _step16$value[1];

                  pointsString += node.x + ',' + node.y;

                  if (index < path.nodes.length - 1) {
                    pointsString += ' ';
                  }
                }
              } catch (err) {
                _didIteratorError16 = true;
                _iteratorError16 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion16 && _iterator16.return != null) {
                    _iterator16.return();
                  }
                } finally {
                  if (_didIteratorError16) {
                    throw _iteratorError16;
                  }
                }
              }

              var d = toPath({
                type: 'polyline',
                points: pointsString
              }); // svg.appendChild(
              //   document.createElement('path').setAttribute('d', d)
              // );
            }
          } catch (err) {
            _didIteratorError15 = true;
            _iteratorError15 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion15 && _iterator15.return != null) {
                _iterator15.return();
              }
            } finally {
              if (_didIteratorError15) {
                throw _iteratorError15;
              }
            }
          }

          console.log(svg);
        } // Remove all paths from the world -----------------

      }, {
        key: "clearPaths",
        value: function clearPaths() {
          this.paths = [];
        } // Pause the simulation ----------------------------

      }, {
        key: "pause",
        value: function pause() {
          this.paused = true;
        } // Unpause the simulation --------------------------

      }, {
        key: "unpause",
        value: function unpause() {
          this.paused = false;
        } // Getters -----------------------------------------

      }, {
        key: "getDrawNodes",
        value: function getDrawNodes() {
          return this.drawNodes;
        }
      }, {
        key: "getDebugMode",
        value: function getDebugMode() {
          return this.debugMode;
        }
      }, {
        key: "getFillMode",
        value: function getFillMode() {
          return this.fillMode;
        } // Setters -----------------------------------------

      }, {
        key: "setDrawNodes",
        value: function setDrawNodes(state) {
          this.drawBackground();
          var _iteratorNormalCompletion17 = true;
          var _didIteratorError17 = false;
          var _iteratorError17 = undefined;

          try {
            for (var _iterator17 = this.paths[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
              var path = _step17.value;
              path.drawNodes = state;
              path.draw();
            }
          } catch (err) {
            _didIteratorError17 = true;
            _iteratorError17 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion17 && _iterator17.return != null) {
                _iterator17.return();
              }
            } finally {
              if (_didIteratorError17) {
                throw _iteratorError17;
              }
            }
          }

          this.drawNodes = state;
        }
      }, {
        key: "setDebugMode",
        value: function setDebugMode(state) {
          this.drawBackground();
          var _iteratorNormalCompletion18 = true;
          var _didIteratorError18 = false;
          var _iteratorError18 = undefined;

          try {
            for (var _iterator18 = this.paths[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
              var path = _step18.value;
              path.debugMode = state;
              path.draw();
            }
          } catch (err) {
            _didIteratorError18 = true;
            _iteratorError18 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion18 && _iterator18.return != null) {
                _iterator18.return();
              }
            } finally {
              if (_didIteratorError18) {
                throw _iteratorError18;
              }
            }
          }

          this.debugMode = state;
        }
      }, {
        key: "setFillMode",
        value: function setFillMode(state) {
          this.drawBackground();
          var _iteratorNormalCompletion19 = true;
          var _didIteratorError19 = false;
          var _iteratorError19 = undefined;

          try {
            for (var _iterator19 = this.paths[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
              var path = _step19.value;
              path.fillMode = state;
              path.draw();
            }
          } catch (err) {
            _didIteratorError19 = true;
            _iteratorError19 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion19 && _iterator19.return != null) {
                _iterator19.return();
              }
            } finally {
              if (_didIteratorError19) {
                throw _iteratorError19;
              }
            }
          }

          this.fillMode = state;
        } // Toggles ----------------------------------

      }, {
        key: "toggleDrawNodes",
        value: function toggleDrawNodes() {
          this.setDrawNodes(!this.getDrawNodes());
        }
      }, {
        key: "toggleTraceMode",
        value: function toggleTraceMode() {
          this.traceMode = !this.traceMode;
          this.drawBackground();
          var _iteratorNormalCompletion20 = true;
          var _didIteratorError20 = false;
          var _iteratorError20 = undefined;

          try {
            for (var _iterator20 = this.paths[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
              var path = _step20.value;
              path.toggleTraceMode();
              path.draw();
            }
          } catch (err) {
            _didIteratorError20 = true;
            _iteratorError20 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion20 && _iterator20.return != null) {
                _iterator20.return();
              }
            } finally {
              if (_didIteratorError20) {
                throw _iteratorError20;
              }
            }
          }
        }
      }, {
        key: "toggleInvertedColors",
        value: function toggleInvertedColors() {
          this.invertedColors = !this.invertedColors;
          this.drawBackground();
          var _iteratorNormalCompletion21 = true;
          var _didIteratorError21 = false;
          var _iteratorError21 = undefined;

          try {
            for (var _iterator21 = this.paths[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
              var path = _step21.value;
              path.toggleInvertedColors();
              path.draw();
            }
          } catch (err) {
            _didIteratorError21 = true;
            _iteratorError21 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion21 && _iterator21.return != null) {
                _iterator21.return();
              }
            } finally {
              if (_didIteratorError21) {
                throw _iteratorError21;
              }
            }
          }
        }
      }, {
        key: "toggleDebugMode",
        value: function toggleDebugMode() {
          this.setDebugMode(!this.getDebugMode());
        }
      }, {
        key: "toggleFillMode",
        value: function toggleFillMode() {
          this.setFillMode(!this.getFillMode());
        }
      }]);

      return World;
    }();

    module.exports = World;
  }, {
    "./Defaults": 3,
    "./node_modules/rbush": 10,
    "./node_modules/svg-points/": 11
  }],
  8: [function (require, module, exports) {
    (function (global, factory) {
      _typeof2(exports) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.quickselect = factory();
    })(this, function () {
      'use strict';

      function quickselect(arr, k, left, right, compare) {
        quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
      }

      function quickselectStep(arr, k, left, right, compare) {
        while (right > left) {
          if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
          }

          var t = arr[k];
          var i = left;
          var j = right;
          swap(arr, left, k);
          if (compare(arr[right], t) > 0) swap(arr, left, right);

          while (i < j) {
            swap(arr, i, j);
            i++;
            j--;

            while (compare(arr[i], t) < 0) {
              i++;
            }

            while (compare(arr[j], t) > 0) {
              j--;
            }
          }

          if (compare(arr[left], t) === 0) swap(arr, left, j);else {
            j++;
            swap(arr, j, right);
          }
          if (j <= k) left = j + 1;
          if (k <= j) right = j - 1;
        }
      }

      function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }

      function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }

      return quickselect;
    });
  }, {}],
  9: [function (require, module, exports) {
    'use strict';

    var Queue = require('tinyqueue');

    module.exports = knn;
    module.exports.default = knn;

    function knn(tree, x, y, n, predicate, maxDistance) {
      var node = tree.data,
          result = [],
          toBBox = tree.toBBox,
          i,
          child,
          dist,
          candidate;
      var queue = new Queue(null, compareDist);

      while (node) {
        for (i = 0; i < node.children.length; i++) {
          child = node.children[i];
          dist = boxDist(x, y, node.leaf ? toBBox(child) : child);

          if (!maxDistance || dist <= maxDistance) {
            queue.push({
              node: child,
              isItem: node.leaf,
              dist: dist
            });
          }
        }

        while (queue.length && queue.peek().isItem) {
          candidate = queue.pop().node;
          if (!predicate || predicate(candidate)) result.push(candidate);
          if (n && result.length === n) return result;
        }

        node = queue.pop();
        if (node) node = node.node;
      }

      return result;
    }

    function compareDist(a, b) {
      return a.dist - b.dist;
    }

    function boxDist(x, y, box) {
      var dx = axisDist(x, box.minX, box.maxX),
          dy = axisDist(y, box.minY, box.maxY);
      return dx * dx + dy * dy;
    }

    function axisDist(k, min, max) {
      return k < min ? min - k : k <= max ? 0 : k - max;
    }
  }, {
    "tinyqueue": 15
  }],
  10: [function (require, module, exports) {
    'use strict';

    module.exports = rbush;
    module.exports.default = rbush;

    var quickselect = require('quickselect');

    function rbush(maxEntries, format) {
      if (!(this instanceof rbush)) return new rbush(maxEntries, format); // max entries in a node is 9 by default; min node fill is 40% for best performance

      this._maxEntries = Math.max(4, maxEntries || 9);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

      if (format) {
        this._initFormat(format);
      }

      this.clear();
    }

    rbush.prototype = {
      all: function all() {
        return this._all(this.data, []);
      },
      search: function search(bbox) {
        var node = this.data,
            result = [],
            toBBox = this.toBBox;
        if (!intersects(bbox, node)) return result;
        var nodesToSearch = [],
            i,
            len,
            child,
            childBBox;

        while (node) {
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;

            if (intersects(bbox, childBBox)) {
              if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);
            }
          }

          node = nodesToSearch.pop();
        }

        return result;
      },
      collides: function collides(bbox) {
        var node = this.data,
            toBBox = this.toBBox;
        if (!intersects(bbox, node)) return false;
        var nodesToSearch = [],
            i,
            len,
            child,
            childBBox;

        while (node) {
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;

            if (intersects(bbox, childBBox)) {
              if (node.leaf || contains(bbox, childBBox)) return true;
              nodesToSearch.push(child);
            }
          }

          node = nodesToSearch.pop();
        }

        return false;
      },
      load: function load(data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
          for (var i = 0, len = data.length; i < len; i++) {
            this.insert(data[i]);
          }

          return this;
        } // recursively build the tree with the given data from scratch using OMT algorithm


        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
          // save as is if tree is empty
          this.data = node;
        } else if (this.data.height === node.height) {
          // split root if trees have the same height
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            // swap trees if inserted one is bigger
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          } // insert the small tree into the large tree at appropriate level


          this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
      },
      insert: function insert(item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
      },
      clear: function clear() {
        this.data = createNode([]);
        return this;
      },
      remove: function remove(item, equalsFn) {
        if (!item) return this;
        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i,
            parent,
            index,
            goingUp; // depth-first iterative tree traversal

        while (node || path.length) {
          if (!node) {
            // go up
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
          }

          if (node.leaf) {
            // check current node
            index = findItem(item, node.children, equalsFn);

            if (index !== -1) {
              // item found, remove the item and condense tree upwards
              node.children.splice(index, 1);
              path.push(node);

              this._condense(path);

              return this;
            }
          }

          if (!goingUp && !node.leaf && contains(node, bbox)) {
            // go down
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            // go right
            i++;
            node = parent.children[i];
            goingUp = false;
          } else node = null; // nothing found

        }

        return this;
      },
      toBBox: function toBBox(item) {
        return item;
      },
      compareMinX: compareNodeMinX,
      compareMinY: compareNodeMinY,
      toJSON: function toJSON() {
        return this.data;
      },
      fromJSON: function fromJSON(data) {
        this.data = data;
        return this;
      },
      _all: function _all(node, result) {
        var nodesToSearch = [];

        while (node) {
          if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);
          node = nodesToSearch.pop();
        }

        return result;
      },
      _build: function _build(items, left, right, height) {
        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
          // reached leaf level; return leaf
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
        }

        if (!height) {
          // target height of the bulk-loaded tree
          height = Math.ceil(Math.log(N) / Math.log(M)); // target number of root entries to maximize storage utilization

          M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height; // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i,
            j,
            right2,
            right3;
        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {
          right2 = Math.min(i + N1 - 1, right);
          multiSelect(items, i, right2, N2, this.compareMinY);

          for (j = i; j <= right2; j += N2) {
            right3 = Math.min(j + N2 - 1, right2); // pack each entry recursively

            node.children.push(this._build(items, j, right3, height - 1));
          }
        }

        calcBBox(node, this.toBBox);
        return node;
      },
      _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {
        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
          path.push(node);
          if (node.leaf || path.length - 1 === level) break;
          minArea = minEnlargement = Infinity;

          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            area = bboxArea(child);
            enlargement = enlargedArea(bbox, child) - area; // choose entry with the least area enlargement

            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area < minArea ? area : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              // otherwise choose one with the smallest area
              if (area < minArea) {
                minArea = area;
                targetNode = child;
              }
            }
          }

          node = targetNode || node.children[0];
        }

        return node;
      },
      _insert: function _insert(item, level, isNode) {
        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = []; // find the best node for accommodating the item, saving all nodes along the path too

        var node = this._chooseSubtree(bbox, this.data, level, insertPath); // put the item into the node


        node.children.push(item);
        extend(node, bbox); // split on node overflow; propagate upwards if necessary

        while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
            this._split(insertPath, level);

            level--;
          } else break;
        } // adjust bboxes along the insertion path


        this._adjustParentBBoxes(bbox, insertPath, level);
      },
      // split overflowed node into two
      _split: function _split(insertPath, level) {
        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);
      },
      _splitRoot: function _splitRoot(node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
      },
      _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {
        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
          bbox1 = distBBox(node, 0, i, this.toBBox);
          bbox2 = distBBox(node, i, M, this.toBBox);
          overlap = intersectionArea(bbox1, bbox2);
          area = bboxArea(bbox1) + bboxArea(bbox2); // choose distribution with minimum overlap

          if (overlap < minOverlap) {
            minOverlap = overlap;
            index = i;
            minArea = area < minArea ? area : minArea;
          } else if (overlap === minOverlap) {
            // otherwise choose distribution with minimum area
            if (area < minArea) {
              minArea = area;
              index = i;
            }
          }
        }

        return index;
      },
      // sorts node children by the best axis for split
      _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY); // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY


        if (xMargin < yMargin) node.children.sort(compareMinX);
      },
      // total margin of all possible split distributions where each node is at least m full
      _allDistMargin: function _allDistMargin(node, m, M, compare) {
        node.children.sort(compare);
        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i,
            child;

        for (i = m; i < M - m; i++) {
          child = node.children[i];
          extend(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
          child = node.children[i];
          extend(rightBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(rightBBox);
        }

        return margin;
      },
      _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
          extend(path[i], bbox);
        }
      },
      _condense: function _condense(path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
          if (path[i].children.length === 0) {
            if (i > 0) {
              siblings = path[i - 1].children;
              siblings.splice(siblings.indexOf(path[i]), 1);
            } else this.clear();
          } else calcBBox(path[i], this.toBBox);
        }
      },
      _initFormat: function _initFormat(format) {
        // data format (minX, minY, maxX, maxY accessors)
        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls
        var compareArr = ['return a', ' - b', ';'];
        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));
        this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');
      }
    };

    function findItem(item, items, equalsFn) {
      if (!equalsFn) return items.indexOf(item);

      for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
      }

      return -1;
    } // calculate node's bbox from bboxes of its children


    function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
    } // min bounding rectangle of node children from k to p-1


    function distBBox(node, k, p, toBBox, destNode) {
      if (!destNode) destNode = createNode(null);
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;

      for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
      }

      return destNode;
    }

    function extend(a, b) {
      a.minX = Math.min(a.minX, b.minX);
      a.minY = Math.min(a.minY, b.minY);
      a.maxX = Math.max(a.maxX, b.maxX);
      a.maxY = Math.max(a.maxY, b.maxY);
      return a;
    }

    function compareNodeMinX(a, b) {
      return a.minX - b.minX;
    }

    function compareNodeMinY(a, b) {
      return a.minY - b.minY;
    }

    function bboxArea(a) {
      return (a.maxX - a.minX) * (a.maxY - a.minY);
    }

    function bboxMargin(a) {
      return a.maxX - a.minX + (a.maxY - a.minY);
    }

    function enlargedArea(a, b) {
      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
    }

    function intersectionArea(a, b) {
      var minX = Math.max(a.minX, b.minX),
          minY = Math.max(a.minY, b.minY),
          maxX = Math.min(a.maxX, b.maxX),
          maxY = Math.min(a.maxY, b.maxY);
      return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
    }

    function contains(a, b) {
      return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
    }

    function intersects(a, b) {
      return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
    }

    function createNode(children) {
      return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
      };
    } // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
    // combines selection algorithm with binary divide & conquer approach


    function multiSelect(arr, left, right, n, compare) {
      var stack = [left, right],
          mid;

      while (stack.length) {
        right = stack.pop();
        left = stack.pop();
        if (right - left <= n) continue;
        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);
        stack.push(left, mid, mid, right);
      }
    }
  }, {
    "quickselect": 8
  }],
  11: [function (require, module, exports) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.valid = exports.toPoints = exports.toPath = undefined;

    var _toPath = require('./toPath');

    var _toPath2 = _interopRequireDefault(_toPath);

    var _toPoints = require('./toPoints');

    var _toPoints2 = _interopRequireDefault(_toPoints);

    var _valid = require('./valid');

    var _valid2 = _interopRequireDefault(_valid);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    exports.toPath = _toPath2.default;
    exports.toPoints = _toPoints2.default;
    exports.valid = _valid2.default;
  }, {
    "./toPath": 12,
    "./toPoints": 13,
    "./valid": 14
  }],
  12: [function (require, module, exports) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _toPoints = require('./toPoints');

    var _toPoints2 = _interopRequireDefault(_toPoints);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    var pointsToD = function pointsToD(p) {
      var d = '';
      var i = 0;
      var firstPoint = void 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = p[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var point = _step.value;
          var _point$curve = point.curve,
              curve = _point$curve === undefined ? false : _point$curve,
              moveTo = point.moveTo,
              x = point.x,
              y = point.y;
          var isFirstPoint = i === 0 || moveTo;
          var isLastPoint = i === p.length - 1 || p[i + 1].moveTo;
          var prevPoint = i === 0 ? null : p[i - 1];

          if (isFirstPoint) {
            firstPoint = point;

            if (!isLastPoint) {
              d += 'M' + x + ',' + y;
            }
          } else if (curve) {
            switch (curve.type) {
              case 'arc':
                var _point$curve2 = point.curve,
                    _point$curve2$largeAr = _point$curve2.largeArcFlag,
                    largeArcFlag = _point$curve2$largeAr === undefined ? 0 : _point$curve2$largeAr,
                    rx = _point$curve2.rx,
                    ry = _point$curve2.ry,
                    _point$curve2$sweepFl = _point$curve2.sweepFlag,
                    sweepFlag = _point$curve2$sweepFl === undefined ? 0 : _point$curve2$sweepFl,
                    _point$curve2$xAxisRo = _point$curve2.xAxisRotation,
                    xAxisRotation = _point$curve2$xAxisRo === undefined ? 0 : _point$curve2$xAxisRo;
                d += 'A' + rx + ',' + ry + ',' + xAxisRotation + ',' + largeArcFlag + ',' + sweepFlag + ',' + x + ',' + y;
                break;

              case 'cubic':
                var _point$curve3 = point.curve,
                    cx1 = _point$curve3.x1,
                    cy1 = _point$curve3.y1,
                    cx2 = _point$curve3.x2,
                    cy2 = _point$curve3.y2;
                d += 'C' + cx1 + ',' + cy1 + ',' + cx2 + ',' + cy2 + ',' + x + ',' + y;
                break;

              case 'quadratic':
                var _point$curve4 = point.curve,
                    qx1 = _point$curve4.x1,
                    qy1 = _point$curve4.y1;
                d += 'Q' + qx1 + ',' + qy1 + ',' + x + ',' + y;
                break;
            }

            if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {
              d += 'Z';
            }
          } else if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {
            d += 'Z';
          } else if (x !== prevPoint.x && y !== prevPoint.y) {
            d += 'L' + x + ',' + y;
          } else if (x !== prevPoint.x) {
            d += 'H' + x;
          } else if (y !== prevPoint.y) {
            d += 'V' + y;
          }

          i++;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return d;
    };

    var toPath = function toPath(s) {
      var isPoints = Array.isArray(s);
      var isGroup = isPoints ? Array.isArray(s[0]) : s.type === 'g';
      var points = isPoints ? s : isGroup ? s.shapes.map(function (shp) {
        return (0, _toPoints2.default)(shp);
      }) : (0, _toPoints2.default)(s);

      if (isGroup) {
        return points.map(function (p) {
          return pointsToD(p);
        });
      }

      return pointsToD(points);
    };

    exports.default = toPath;
  }, {
    "./toPoints": 13
  }],
  13: [function (require, module, exports) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    function _objectWithoutProperties(obj, keys) {
      var target = {};

      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }

      return target;
    }

    var toPoints = function toPoints(_ref) {
      var type = _ref.type,
          props = _objectWithoutProperties(_ref, ['type']);

      switch (type) {
        case 'circle':
          return getPointsFromCircle(props);

        case 'ellipse':
          return getPointsFromEllipse(props);

        case 'line':
          return getPointsFromLine(props);

        case 'path':
          return getPointsFromPath(props);

        case 'polygon':
          return getPointsFromPolygon(props);

        case 'polyline':
          return getPointsFromPolyline(props);

        case 'rect':
          return getPointsFromRect(props);

        case 'g':
          return getPointsFromG(props);

        default:
          throw new Error('Not a valid shape type');
      }
    };

    var getPointsFromCircle = function getPointsFromCircle(_ref2) {
      var cx = _ref2.cx,
          cy = _ref2.cy,
          r = _ref2.r;
      return [{
        x: cx,
        y: cy - r,
        moveTo: true
      }, {
        x: cx,
        y: cy + r,
        curve: {
          type: 'arc',
          rx: r,
          ry: r,
          sweepFlag: 1
        }
      }, {
        x: cx,
        y: cy - r,
        curve: {
          type: 'arc',
          rx: r,
          ry: r,
          sweepFlag: 1
        }
      }];
    };

    var getPointsFromEllipse = function getPointsFromEllipse(_ref3) {
      var cx = _ref3.cx,
          cy = _ref3.cy,
          rx = _ref3.rx,
          ry = _ref3.ry;
      return [{
        x: cx,
        y: cy - ry,
        moveTo: true
      }, {
        x: cx,
        y: cy + ry,
        curve: {
          type: 'arc',
          rx: rx,
          ry: ry,
          sweepFlag: 1
        }
      }, {
        x: cx,
        y: cy - ry,
        curve: {
          type: 'arc',
          rx: rx,
          ry: ry,
          sweepFlag: 1
        }
      }];
    };

    var getPointsFromLine = function getPointsFromLine(_ref4) {
      var x1 = _ref4.x1,
          x2 = _ref4.x2,
          y1 = _ref4.y1,
          y2 = _ref4.y2;
      return [{
        x: x1,
        y: y1,
        moveTo: true
      }, {
        x: x2,
        y: y2
      }];
    };

    var validCommands = /[MmLlHhVvCcSsQqTtAaZz]/g;
    var commandLengths = {
      A: 7,
      C: 6,
      H: 1,
      L: 2,
      M: 2,
      Q: 4,
      S: 4,
      T: 2,
      V: 1,
      Z: 0
    };
    var relativeCommands = ['a', 'c', 'h', 'l', 'm', 'q', 's', 't', 'v'];

    var isRelative = function isRelative(command) {
      return relativeCommands.indexOf(command) !== -1;
    };

    var optionalArcKeys = ['xAxisRotation', 'largeArcFlag', 'sweepFlag'];

    var getCommands = function getCommands(d) {
      return d.match(validCommands);
    };

    var getParams = function getParams(d) {
      return d.split(validCommands).map(function (v) {
        return v.replace(/[0-9]+-/g, function (m) {
          return m.slice(0, -1) + ' -';
        });
      }).map(function (v) {
        return v.replace(/\.[0-9]+/g, function (m) {
          return m + ' ';
        });
      }).map(function (v) {
        return v.trim();
      }).filter(function (v) {
        return v.length > 0;
      }).map(function (v) {
        return v.split(/[ ,]+/).map(parseFloat).filter(function (n) {
          return !isNaN(n);
        });
      });
    };

    var getPointsFromPath = function getPointsFromPath(_ref5) {
      var d = _ref5.d;
      var commands = getCommands(d);
      var params = getParams(d);
      var points = [];
      var moveTo = void 0;

      for (var i = 0, l = commands.length; i < l; i++) {
        var command = commands[i];
        var upperCaseCommand = command.toUpperCase();
        var commandLength = commandLengths[upperCaseCommand];
        var relative = isRelative(command);

        if (commandLength > 0) {
          var commandParams = params.shift();
          var iterations = commandParams.length / commandLength;

          for (var j = 0; j < iterations; j++) {
            var prevPoint = points[points.length - 1] || {
              x: 0,
              y: 0
            };

            switch (upperCaseCommand) {
              case 'M':
                var x = (relative ? prevPoint.x : 0) + commandParams.shift();
                var y = (relative ? prevPoint.y : 0) + commandParams.shift();

                if (j === 0) {
                  moveTo = {
                    x: x,
                    y: y
                  };
                  points.push({
                    x: x,
                    y: y,
                    moveTo: true
                  });
                } else {
                  points.push({
                    x: x,
                    y: y
                  });
                }

                break;

              case 'L':
                points.push({
                  x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                  y: (relative ? prevPoint.y : 0) + commandParams.shift()
                });
                break;

              case 'H':
                points.push({
                  x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                  y: prevPoint.y
                });
                break;

              case 'V':
                points.push({
                  x: prevPoint.x,
                  y: (relative ? prevPoint.y : 0) + commandParams.shift()
                });
                break;

              case 'A':
                points.push({
                  curve: {
                    type: 'arc',
                    rx: commandParams.shift(),
                    ry: commandParams.shift(),
                    xAxisRotation: commandParams.shift(),
                    largeArcFlag: commandParams.shift(),
                    sweepFlag: commandParams.shift()
                  },
                  x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                  y: (relative ? prevPoint.y : 0) + commandParams.shift()
                });
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                  for (var _iterator = optionalArcKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var k = _step.value;

                    if (points[points.length - 1]['curve'][k] === 0) {
                      delete points[points.length - 1]['curve'][k];
                    }
                  }
                } catch (err) {
                  _didIteratorError = true;
                  _iteratorError = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                      _iterator.return();
                    }
                  } finally {
                    if (_didIteratorError) {
                      throw _iteratorError;
                    }
                  }
                }

                break;

              case 'C':
                points.push({
                  curve: {
                    type: 'cubic',
                    x1: (relative ? prevPoint.x : 0) + commandParams.shift(),
                    y1: (relative ? prevPoint.y : 0) + commandParams.shift(),
                    x2: (relative ? prevPoint.x : 0) + commandParams.shift(),
                    y2: (relative ? prevPoint.y : 0) + commandParams.shift()
                  },
                  x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                  y: (relative ? prevPoint.y : 0) + commandParams.shift()
                });
                break;

              case 'S':
                var sx2 = (relative ? prevPoint.x : 0) + commandParams.shift();
                var sy2 = (relative ? prevPoint.y : 0) + commandParams.shift();
                var sx = (relative ? prevPoint.x : 0) + commandParams.shift();
                var sy = (relative ? prevPoint.y : 0) + commandParams.shift();
                var diff = {};
                var sx1 = void 0;
                var sy1 = void 0;

                if (prevPoint.curve && prevPoint.curve.type === 'cubic') {
                  diff.x = Math.abs(prevPoint.x - prevPoint.curve.x2);
                  diff.y = Math.abs(prevPoint.y - prevPoint.curve.y2);
                  sx1 = prevPoint.x < prevPoint.curve.x2 ? prevPoint.x - diff.x : prevPoint.x + diff.x;
                  sy1 = prevPoint.y < prevPoint.curve.y2 ? prevPoint.y - diff.y : prevPoint.y + diff.y;
                } else {
                  diff.x = Math.abs(sx - sx2);
                  diff.y = Math.abs(sy - sy2);
                  sx1 = prevPoint.x;
                  sy1 = prevPoint.y;
                }

                points.push({
                  curve: {
                    type: 'cubic',
                    x1: sx1,
                    y1: sy1,
                    x2: sx2,
                    y2: sy2
                  },
                  x: sx,
                  y: sy
                });
                break;

              case 'Q':
                points.push({
                  curve: {
                    type: 'quadratic',
                    x1: (relative ? prevPoint.x : 0) + commandParams.shift(),
                    y1: (relative ? prevPoint.y : 0) + commandParams.shift()
                  },
                  x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                  y: (relative ? prevPoint.y : 0) + commandParams.shift()
                });
                break;

              case 'T':
                var tx = (relative ? prevPoint.x : 0) + commandParams.shift();
                var ty = (relative ? prevPoint.y : 0) + commandParams.shift();
                var tx1 = void 0;
                var ty1 = void 0;

                if (prevPoint.curve && prevPoint.curve.type === 'quadratic') {
                  var _diff = {
                    x: Math.abs(prevPoint.x - prevPoint.curve.x1),
                    y: Math.abs(prevPoint.y - prevPoint.curve.y1)
                  };
                  tx1 = prevPoint.x < prevPoint.curve.x1 ? prevPoint.x - _diff.x : prevPoint.x + _diff.x;
                  ty1 = prevPoint.y < prevPoint.curve.y1 ? prevPoint.y - _diff.y : prevPoint.y + _diff.y;
                } else {
                  tx1 = prevPoint.x;
                  ty1 = prevPoint.y;
                }

                points.push({
                  curve: {
                    type: 'quadratic',
                    x1: tx1,
                    y1: ty1
                  },
                  x: tx,
                  y: ty
                });
                break;
            }
          }
        } else {
          var _prevPoint = points[points.length - 1] || {
            x: 0,
            y: 0
          };

          if (_prevPoint.x !== moveTo.x || _prevPoint.y !== moveTo.y) {
            points.push({
              x: moveTo.x,
              y: moveTo.y
            });
          }
        }
      }

      return points;
    };

    var getPointsFromPolygon = function getPointsFromPolygon(_ref6) {
      var points = _ref6.points;
      return getPointsFromPoints({
        closed: true,
        points: points
      });
    };

    var getPointsFromPolyline = function getPointsFromPolyline(_ref7) {
      var points = _ref7.points;
      return getPointsFromPoints({
        closed: false,
        points: points
      });
    };

    var getPointsFromPoints = function getPointsFromPoints(_ref8) {
      var closed = _ref8.closed,
          points = _ref8.points;
      var numbers = points.split(/[\s,]+/).map(function (n) {
        return parseFloat(n);
      });
      var p = numbers.reduce(function (arr, point, i) {
        if (i % 2 === 0) {
          arr.push({
            x: point
          });
        } else {
          arr[(i - 1) / 2].y = point;
        }

        return arr;
      }, []);

      if (closed) {
        p.push(_extends({}, p[0]));
      }

      p[0].moveTo = true;
      return p;
    };

    var getPointsFromRect = function getPointsFromRect(_ref9) {
      var height = _ref9.height,
          rx = _ref9.rx,
          ry = _ref9.ry,
          width = _ref9.width,
          x = _ref9.x,
          y = _ref9.y;

      if (rx || ry) {
        return getPointsFromRectWithCornerRadius({
          height: height,
          rx: rx || ry,
          ry: ry || rx,
          width: width,
          x: x,
          y: y
        });
      }

      return getPointsFromBasicRect({
        height: height,
        width: width,
        x: x,
        y: y
      });
    };

    var getPointsFromBasicRect = function getPointsFromBasicRect(_ref10) {
      var height = _ref10.height,
          width = _ref10.width,
          x = _ref10.x,
          y = _ref10.y;
      return [{
        x: x,
        y: y,
        moveTo: true
      }, {
        x: x + width,
        y: y
      }, {
        x: x + width,
        y: y + height
      }, {
        x: x,
        y: y + height
      }, {
        x: x,
        y: y
      }];
    };

    var getPointsFromRectWithCornerRadius = function getPointsFromRectWithCornerRadius(_ref11) {
      var height = _ref11.height,
          rx = _ref11.rx,
          ry = _ref11.ry,
          width = _ref11.width,
          x = _ref11.x,
          y = _ref11.y;
      var curve = {
        type: 'arc',
        rx: rx,
        ry: ry,
        sweepFlag: 1
      };
      return [{
        x: x + rx,
        y: y,
        moveTo: true
      }, {
        x: x + width - rx,
        y: y
      }, {
        x: x + width,
        y: y + ry,
        curve: curve
      }, {
        x: x + width,
        y: y + height - ry
      }, {
        x: x + width - rx,
        y: y + height,
        curve: curve
      }, {
        x: x + rx,
        y: y + height
      }, {
        x: x,
        y: y + height - ry,
        curve: curve
      }, {
        x: x,
        y: y + ry
      }, {
        x: x + rx,
        y: y,
        curve: curve
      }];
    };

    var getPointsFromG = function getPointsFromG(_ref12) {
      var shapes = _ref12.shapes;
      return shapes.map(function (s) {
        return toPoints(s);
      });
    };

    exports.default = toPoints;
  }, {}],
  14: [function (require, module, exports) {
    'use strict';

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
      return _typeof2(obj);
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };

    var getErrors = function getErrors(shape) {
      var rules = getRules(shape);
      var errors = [];
      rules.map(function (_ref) {
        var match = _ref.match,
            prop = _ref.prop,
            required = _ref.required,
            type = _ref.type;

        if (typeof shape[prop] === 'undefined') {
          if (required) {
            errors.push(prop + ' prop is required' + (prop === 'type' ? '' : ' on a ' + shape.type));
          }
        } else {
          if (typeof type !== 'undefined') {
            if (type === 'array') {
              if (!Array.isArray(shape[prop])) {
                errors.push(prop + ' prop must be of type array');
              }
            } else if (_typeof(shape[prop]) !== type) {
              // eslint-disable-line valid-typeof
              errors.push(prop + ' prop must be of type ' + type);
            }
          }

          if (Array.isArray(match)) {
            if (match.indexOf(shape[prop]) === -1) {
              errors.push(prop + ' prop must be one of ' + match.join(', '));
            }
          }
        }
      });

      if (shape.type === 'g' && Array.isArray(shape.shapes)) {
        var childErrors = shape.shapes.map(function (s) {
          return getErrors(s);
        });
        return [].concat.apply(errors, childErrors);
      }

      return errors;
    };

    var getRules = function getRules(shape) {
      var rules = [{
        match: ['circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect', 'g'],
        prop: 'type',
        required: true,
        type: 'string'
      }];

      switch (shape.type) {
        case 'circle':
          rules.push({
            prop: 'cx',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'cy',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'r',
            required: true,
            type: 'number'
          });
          break;

        case 'ellipse':
          rules.push({
            prop: 'cx',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'cy',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'rx',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'ry',
            required: true,
            type: 'number'
          });
          break;

        case 'line':
          rules.push({
            prop: 'x1',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'x2',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'y1',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'y2',
            required: true,
            type: 'number'
          });
          break;

        case 'path':
          rules.push({
            prop: 'd',
            required: true,
            type: 'string'
          });
          break;

        case 'polygon':
        case 'polyline':
          rules.push({
            prop: 'points',
            required: true,
            type: 'string'
          });
          break;

        case 'rect':
          rules.push({
            prop: 'height',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'rx',
            type: 'number'
          });
          rules.push({
            prop: 'ry',
            type: 'number'
          });
          rules.push({
            prop: 'width',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'x',
            required: true,
            type: 'number'
          });
          rules.push({
            prop: 'y',
            required: true,
            type: 'number'
          });
          break;

        case 'g':
          rules.push({
            prop: 'shapes',
            required: true,
            type: 'array'
          });
          break;
      }

      return rules;
    };

    var valid = function valid(shape) {
      var errors = getErrors(shape);
      return {
        errors: errors,
        valid: errors.length === 0
      };
    };

    exports.default = valid;
  }, {}],
  15: [function (require, module, exports) {
    'use strict';

    module.exports = TinyQueue;
    module.exports.default = TinyQueue;

    function TinyQueue(data, compare) {
      if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);
      this.data = data || [];
      this.length = this.data.length;
      this.compare = compare || defaultCompare;

      if (this.length > 0) {
        for (var i = (this.length >> 1) - 1; i >= 0; i--) {
          this._down(i);
        }
      }
    }

    function defaultCompare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }

    TinyQueue.prototype = {
      push: function push(item) {
        this.data.push(item);
        this.length++;

        this._up(this.length - 1);
      },
      pop: function pop() {
        if (this.length === 0) return undefined;
        var top = this.data[0];
        this.length--;

        if (this.length > 0) {
          this.data[0] = this.data[this.length];

          this._down(0);
        }

        this.data.pop();
        return top;
      },
      peek: function peek() {
        return this.data[0];
      },
      _up: function _up(pos) {
        var data = this.data;
        var compare = this.compare;
        var item = data[pos];

        while (pos > 0) {
          var parent = pos - 1 >> 1;
          var current = data[parent];
          if (compare(item, current) >= 0) break;
          data[pos] = current;
          pos = parent;
        }

        data[pos] = item;
      },
      _down: function _down(pos) {
        var data = this.data;
        var compare = this.compare;
        var halfLength = this.length >> 1;
        var item = data[pos];

        while (pos < halfLength) {
          var left = (pos << 1) + 1;
          var right = left + 1;
          var best = data[left];

          if (right < this.length && compare(data[right], best) < 0) {
            left = right;
            best = data[right];
          }

          if (compare(best, item) >= 0) break;
          data[pos] = best;
          pos = left;
        }

        data[pos] = item;
      }
    };
  }, {}],
  16: [function (require, module, exports) {
    ;

    (function inject(clean, precision, undef) {
      var isArray = function isArray(a) {
        return Object.prototype.toString.call(a) === "[object Array]";
      };

      var defined = function defined(a) {
        return a !== undef;
      };

      function Vec2(x, y) {
        if (!(this instanceof Vec2)) {
          return new Vec2(x, y);
        }

        if (isArray(x)) {
          y = x[1];
          x = x[0];
        } else if ('object' === _typeof2(x) && x) {
          y = x.y;
          x = x.x;
        }

        this.x = Vec2.clean(x || 0);
        this.y = Vec2.clean(y || 0);
      }

      Vec2.prototype = {
        change: function change(fn) {
          if (typeof fn === 'function') {
            if (this.observers) {
              this.observers.push(fn);
            } else {
              this.observers = [fn];
            }
          } else if (this.observers && this.observers.length) {
            for (var i = this.observers.length - 1; i >= 0; i--) {
              this.observers[i](this, fn);
            }
          }

          return this;
        },
        ignore: function ignore(fn) {
          if (this.observers) {
            if (!fn) {
              this.observers = [];
            } else {
              var o = this.observers,
                  l = o.length;

              while (l--) {
                o[l] === fn && o.splice(l, 1);
              }
            }
          }

          return this;
        },
        // set x and y
        set: function set(x, y, notify) {
          if ('number' != typeof x) {
            notify = y;
            y = x.y;
            x = x.x;
          }

          if (this.x === x && this.y === y) {
            return this;
          }

          var orig = null;

          if (notify !== false && this.observers && this.observers.length) {
            orig = this.clone();
          }

          this.x = Vec2.clean(x);
          this.y = Vec2.clean(y);

          if (notify !== false) {
            return this.change(orig);
          }
        },
        // reset x and y to zero
        zero: function zero() {
          return this.set(0, 0);
        },
        // return a new vector with the same component values
        // as this one
        clone: function clone() {
          return new this.constructor(this.x, this.y);
        },
        // negate the values of this vector
        negate: function negate(returnNew) {
          if (returnNew) {
            return new this.constructor(-this.x, -this.y);
          } else {
            return this.set(-this.x, -this.y);
          }
        },
        // Add the incoming `vec2` vector to this vector
        add: function add(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          }

          x += this.x;
          y += this.y;

          if (!returnNew) {
            return this.set(x, y);
          } else {
            // Return a new vector if `returnNew` is truthy
            return new this.constructor(x, y);
          }
        },
        // Subtract the incoming `vec2` from this vector
        subtract: function subtract(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          }

          x = this.x - x;
          y = this.y - y;

          if (!returnNew) {
            return this.set(x, y);
          } else {
            // Return a new vector if `returnNew` is truthy
            return new this.constructor(x, y);
          }
        },
        // Multiply this vector by the incoming `vec2`
        multiply: function multiply(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          } else if (typeof y != 'number') {
            returnNew = y;
            y = x;
          }

          x *= this.x;
          y *= this.y;

          if (!returnNew) {
            return this.set(x, y);
          } else {
            return new this.constructor(x, y);
          }
        },
        // Rotate this vector. Accepts a `Rotation` or angle in radians.
        //
        // Passing a truthy `inverse` will cause the rotation to
        // be reversed.
        //
        // If `returnNew` is truthy, a new
        // `Vec2` will be created with the values resulting from
        // the rotation. Otherwise the rotation will be applied
        // to this vector directly, and this vector will be returned.
        rotate: function rotate(r, inverse, returnNew) {
          var x = this.x,
              y = this.y,
              cos = Math.cos(r),
              sin = Math.sin(r),
              rx,
              ry;
          inverse = inverse ? -1 : 1;
          rx = cos * x - inverse * sin * y;
          ry = inverse * sin * x + cos * y;

          if (returnNew) {
            return new this.constructor(rx, ry);
          } else {
            return this.set(rx, ry);
          }
        },
        // Calculate the length of this vector
        length: function length() {
          var x = this.x,
              y = this.y;
          return Math.sqrt(x * x + y * y);
        },
        // Get the length squared. For performance, use this instead of `Vec2#length` (if possible).
        lengthSquared: function lengthSquared() {
          var x = this.x,
              y = this.y;
          return x * x + y * y;
        },
        // Return the distance betwen this `Vec2` and the incoming vec2 vector
        // and return a scalar
        distance: function distance(vec2) {
          var x = this.x - vec2.x;
          var y = this.y - vec2.y;
          return Math.sqrt(x * x + y * y);
        },
        // Given Array of Vec2, find closest to this Vec2.
        nearest: function nearest(others) {
          var shortestDistance = Number.MAX_VALUE,
              nearest = null,
              currentDistance;

          for (var i = others.length - 1; i >= 0; i--) {
            currentDistance = this.distance(others[i]);

            if (currentDistance <= shortestDistance) {
              shortestDistance = currentDistance;
              nearest = others[i];
            }
          }

          return nearest;
        },
        // Convert this vector into a unit vector.
        // Returns the length.
        normalize: function normalize(returnNew) {
          var length = this.length(); // Collect a ratio to shrink the x and y coords

          var invertedLength = length < Number.MIN_VALUE ? 0 : 1 / length;

          if (!returnNew) {
            // Convert the coords to be greater than zero
            // but smaller than or equal to 1.0
            return this.set(this.x * invertedLength, this.y * invertedLength);
          } else {
            return new this.constructor(this.x * invertedLength, this.y * invertedLength);
          }
        },
        // Determine if another `Vec2`'s components match this one's
        // also accepts 2 scalars
        equal: function equal(v, w) {
          if (typeof v != 'number') {
            if (isArray(v)) {
              w = v[1];
              v = v[0];
            } else {
              w = v.y;
              v = v.x;
            }
          }

          return Vec2.clean(v) === this.x && Vec2.clean(w) === this.y;
        },
        // Return a new `Vec2` that contains the absolute value of
        // each of this vector's parts
        abs: function abs(returnNew) {
          var x = Math.abs(this.x),
              y = Math.abs(this.y);

          if (returnNew) {
            return new this.constructor(x, y);
          } else {
            return this.set(x, y);
          }
        },
        // Return a new `Vec2` consisting of the smallest values
        // from this vector and the incoming
        //
        // When returnNew is truthy, a new `Vec2` will be returned
        // otherwise the minimum values in either this or `v` will
        // be applied to this vector.
        min: function min(v, returnNew) {
          var tx = this.x,
              ty = this.y,
              vx = v.x,
              vy = v.y,
              x = tx < vx ? tx : vx,
              y = ty < vy ? ty : vy;

          if (returnNew) {
            return new this.constructor(x, y);
          } else {
            return this.set(x, y);
          }
        },
        // Return a new `Vec2` consisting of the largest values
        // from this vector and the incoming
        //
        // When returnNew is truthy, a new `Vec2` will be returned
        // otherwise the minimum values in either this or `v` will
        // be applied to this vector.
        max: function max(v, returnNew) {
          var tx = this.x,
              ty = this.y,
              vx = v.x,
              vy = v.y,
              x = tx > vx ? tx : vx,
              y = ty > vy ? ty : vy;

          if (returnNew) {
            return new this.constructor(x, y);
          } else {
            return this.set(x, y);
          }
        },
        // Clamp values into a range.
        // If this vector's values are lower than the `low`'s
        // values, then raise them.  If they are higher than
        // `high`'s then lower them.
        //
        // Passing returnNew as true will cause a new Vec2 to be
        // returned.  Otherwise, this vector's values will be clamped
        clamp: function clamp(low, high, returnNew) {
          var ret = this.min(high, true).max(low);

          if (returnNew) {
            return ret;
          } else {
            return this.set(ret.x, ret.y);
          }
        },
        // Perform linear interpolation between two vectors
        // amount is a decimal between 0 and 1
        lerp: function lerp(vec, amount, returnNew) {
          return this.add(vec.subtract(this, true).multiply(amount), returnNew);
        },
        // Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
        skew: function skew(returnNew) {
          if (!returnNew) {
            return this.set(-this.y, this.x);
          } else {
            return new this.constructor(-this.y, this.x);
          }
        },
        // calculate the dot product between
        // this vector and the incoming
        dot: function dot(b) {
          return Vec2.clean(this.x * b.x + b.y * this.y);
        },
        // calculate the perpendicular dot product between
        // this vector and the incoming
        perpDot: function perpDot(b) {
          return Vec2.clean(this.x * b.y - this.y * b.x);
        },
        // Determine the angle between two vec2s
        angleTo: function angleTo(vec) {
          return Math.atan2(this.perpDot(vec), this.dot(vec));
        },
        // Divide this vector's components by a scalar
        divide: function divide(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          } else if (typeof y != 'number') {
            returnNew = y;
            y = x;
          }

          if (x === 0 || y === 0) {
            throw new Error('division by zero');
          }

          if (isNaN(x) || isNaN(y)) {
            throw new Error('NaN detected');
          }

          if (returnNew) {
            return new this.constructor(this.x / x, this.y / y);
          }

          return this.set(this.x / x, this.y / y);
        },
        isPointOnLine: function isPointOnLine(start, end) {
          return (start.y - this.y) * (start.x - end.x) === (start.y - end.y) * (start.x - this.x);
        },
        toArray: function toArray() {
          return [this.x, this.y];
        },
        fromArray: function fromArray(array) {
          return this.set(array[0], array[1]);
        },
        toJSON: function toJSON() {
          return {
            x: this.x,
            y: this.y
          };
        },
        toString: function toString() {
          return '(' + this.x + ', ' + this.y + ')';
        },
        constructor: Vec2
      };

      Vec2.fromArray = function (array, ctor) {
        return new (ctor || Vec2)(array[0], array[1]);
      }; // Floating point stability


      Vec2.precision = precision || 8;
      var p = Math.pow(10, Vec2.precision);

      Vec2.clean = clean || function (val) {
        if (isNaN(val)) {
          throw new Error('NaN detected');
        }

        if (!isFinite(val)) {
          throw new Error('Infinity detected');
        }

        if (Math.round(val) === val) {
          return val;
        }

        return Math.round(val * p) / p;
      };

      Vec2.inject = inject;

      if (!clean) {
        Vec2.fast = inject(function (k) {
          return k;
        }); // Expose, but also allow creating a fresh Vec2 subclass.

        if (typeof module !== 'undefined' && _typeof2(module.exports) == 'object') {
          module.exports = Vec2;
        } else {
          window.Vec2 = window.Vec2 || Vec2;
        }
      }

      return Vec2;
    })();
  }, {}],
  17: [function (require, module, exports) {
    /*
    
    WebMidi v2.2.0
    
    WebMidi.js helps you tame the Web MIDI API. Send and receive MIDI messages with ease. Control instruments with user-friendly functions (playNote, sendPitchBend, etc.). React to MIDI input with simple event listeners (noteon, pitchbend, controlchange, etc.).
    https://github.com/djipco/webmidi
    
    
    The MIT License (MIT)
    
    Copyright (c) 2015-2018, Jean-Philippe Ct
    
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
    associated documentation files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge, publish, distribute,
    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in all copies or substantial
    portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
    NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
    OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    */
    !function (scope) {
      "use strict";

      function WebMidi() {
        if (WebMidi.prototype._singleton) throw new Error("WebMidi is a singleton, it cannot be instantiated directly.");
        WebMidi.prototype._singleton = this, this._inputs = [], this._outputs = [], this._userHandlers = {}, this._stateChangeQueue = [], this._processingStateChange = !1, this._midiInterfaceEvents = ["connected", "disconnected"], this._notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"], this._semitones = {
          C: 0,
          D: 2,
          E: 4,
          F: 5,
          G: 7,
          A: 9,
          B: 11
        }, Object.defineProperties(this, {
          MIDI_SYSTEM_MESSAGES: {
            value: {
              sysex: 240,
              timecode: 241,
              songposition: 242,
              songselect: 243,
              tuningrequest: 246,
              sysexend: 247,
              clock: 248,
              start: 250,
              "continue": 251,
              stop: 252,
              activesensing: 254,
              reset: 255,
              midimessage: 0,
              unknownsystemmessage: -1
            },
            writable: !1,
            enumerable: !0,
            configurable: !1
          },
          MIDI_CHANNEL_MESSAGES: {
            value: {
              noteoff: 8,
              noteon: 9,
              keyaftertouch: 10,
              controlchange: 11,
              channelmode: 11,
              programchange: 12,
              channelaftertouch: 13,
              pitchbend: 14
            },
            writable: !1,
            enumerable: !0,
            configurable: !1
          },
          MIDI_REGISTERED_PARAMETER: {
            value: {
              pitchbendrange: [0, 0],
              channelfinetuning: [0, 1],
              channelcoarsetuning: [0, 2],
              tuningprogram: [0, 3],
              tuningbank: [0, 4],
              modulationrange: [0, 5],
              azimuthangle: [61, 0],
              elevationangle: [61, 1],
              gain: [61, 2],
              distanceratio: [61, 3],
              maximumdistance: [61, 4],
              maximumdistancegain: [61, 5],
              referencedistanceratio: [61, 6],
              panspreadangle: [61, 7],
              rollangle: [61, 8]
            },
            writable: !1,
            enumerable: !0,
            configurable: !1
          },
          MIDI_CONTROL_CHANGE_MESSAGES: {
            value: {
              bankselectcoarse: 0,
              modulationwheelcoarse: 1,
              breathcontrollercoarse: 2,
              footcontrollercoarse: 4,
              portamentotimecoarse: 5,
              dataentrycoarse: 6,
              volumecoarse: 7,
              balancecoarse: 8,
              pancoarse: 10,
              expressioncoarse: 11,
              effectcontrol1coarse: 12,
              effectcontrol2coarse: 13,
              generalpurposeslider1: 16,
              generalpurposeslider2: 17,
              generalpurposeslider3: 18,
              generalpurposeslider4: 19,
              bankselectfine: 32,
              modulationwheelfine: 33,
              breathcontrollerfine: 34,
              footcontrollerfine: 36,
              portamentotimefine: 37,
              dataentryfine: 38,
              volumefine: 39,
              balancefine: 40,
              panfine: 42,
              expressionfine: 43,
              effectcontrol1fine: 44,
              effectcontrol2fine: 45,
              holdpedal: 64,
              portamento: 65,
              sustenutopedal: 66,
              softpedal: 67,
              legatopedal: 68,
              hold2pedal: 69,
              soundvariation: 70,
              resonance: 71,
              soundreleasetime: 72,
              soundattacktime: 73,
              brightness: 74,
              soundcontrol6: 75,
              soundcontrol7: 76,
              soundcontrol8: 77,
              soundcontrol9: 78,
              soundcontrol10: 79,
              generalpurposebutton1: 80,
              generalpurposebutton2: 81,
              generalpurposebutton3: 82,
              generalpurposebutton4: 83,
              reverblevel: 91,
              tremololevel: 92,
              choruslevel: 93,
              celestelevel: 94,
              phaserlevel: 95,
              databuttonincrement: 96,
              databuttondecrement: 97,
              nonregisteredparametercoarse: 98,
              nonregisteredparameterfine: 99,
              registeredparametercoarse: 100,
              registeredparameterfine: 101
            },
            writable: !1,
            enumerable: !0,
            configurable: !1
          },
          MIDI_CHANNEL_MODE_MESSAGES: {
            value: {
              allsoundoff: 120,
              resetallcontrollers: 121,
              localcontrol: 122,
              allnotesoff: 123,
              omnimodeoff: 124,
              omnimodeon: 125,
              monomodeon: 126,
              polymodeon: 127
            },
            writable: !1,
            enumerable: !0,
            configurable: !1
          },
          octaveOffset: {
            value: 0,
            writable: !0,
            enumerable: !0,
            configurable: !1
          }
        }), Object.defineProperties(this, {
          supported: {
            enumerable: !0,
            get: function get() {
              return "requestMIDIAccess" in navigator;
            }
          },
          enabled: {
            enumerable: !0,
            get: function () {
              return void 0 !== this["interface"];
            }.bind(this)
          },
          inputs: {
            enumerable: !0,
            get: function () {
              return this._inputs;
            }.bind(this)
          },
          outputs: {
            enumerable: !0,
            get: function () {
              return this._outputs;
            }.bind(this)
          },
          sysexEnabled: {
            enumerable: !0,
            get: function () {
              return !(!this["interface"] || !this["interface"].sysexEnabled);
            }.bind(this)
          },
          time: {
            enumerable: !0,
            get: function get() {
              return performance.now();
            }
          }
        });
      }

      function Input(midiInput) {
        var that = this;
        this._userHandlers = {
          channel: {},
          system: {}
        }, this._midiInput = midiInput, Object.defineProperties(this, {
          connection: {
            enumerable: !0,
            get: function get() {
              return that._midiInput.connection;
            }
          },
          id: {
            enumerable: !0,
            get: function get() {
              return that._midiInput.id;
            }
          },
          manufacturer: {
            enumerable: !0,
            get: function get() {
              return that._midiInput.manufacturer;
            }
          },
          name: {
            enumerable: !0,
            get: function get() {
              return that._midiInput.name;
            }
          },
          state: {
            enumerable: !0,
            get: function get() {
              return that._midiInput.state;
            }
          },
          type: {
            enumerable: !0,
            get: function get() {
              return that._midiInput.type;
            }
          }
        }), this._initializeUserHandlers(), this._midiInput.onmidimessage = this._onMidiMessage.bind(this);
      }

      function Output(midiOutput) {
        var that = this;
        this._midiOutput = midiOutput, Object.defineProperties(this, {
          connection: {
            enumerable: !0,
            get: function get() {
              return that._midiOutput.connection;
            }
          },
          id: {
            enumerable: !0,
            get: function get() {
              return that._midiOutput.id;
            }
          },
          manufacturer: {
            enumerable: !0,
            get: function get() {
              return that._midiOutput.manufacturer;
            }
          },
          name: {
            enumerable: !0,
            get: function get() {
              return that._midiOutput.name;
            }
          },
          state: {
            enumerable: !0,
            get: function get() {
              return that._midiOutput.state;
            }
          },
          type: {
            enumerable: !0,
            get: function get() {
              return that._midiOutput.type;
            }
          }
        });
      }

      var wm = new WebMidi();
      WebMidi.prototype.enable = function (callback, sysex) {
        return this.enabled ? void 0 : this.supported ? void navigator.requestMIDIAccess({
          sysex: sysex
        }).then(function (midiAccess) {
          function onPortsOpen() {
            clearTimeout(promiseTimeout), this._updateInputsAndOutputs(), this["interface"].onstatechange = this._onInterfaceStateChange.bind(this), "function" == typeof callback && callback.call(this), events.forEach(function (event) {
              this._onInterfaceStateChange(event);
            }.bind(this));
          }

          var promiseTimeout,
              events = [],
              promises = [];
          this["interface"] = midiAccess, this._resetInterfaceUserHandlers(), this["interface"].onstatechange = function (e) {
            events.push(e);
          };

          for (var inputs = midiAccess.inputs.values(), input = inputs.next(); input && !input.done; input = inputs.next()) {
            promises.push(input.value.open());
          }

          for (var outputs = midiAccess.outputs.values(), output = outputs.next(); output && !output.done; output = outputs.next()) {
            promises.push(output.value.open());
          }

          promiseTimeout = setTimeout(onPortsOpen.bind(this), 200), Promise && Promise.all(promises)["catch"](function (err) {}).then(onPortsOpen.bind(this));
        }.bind(this), function (err) {
          "function" == typeof callback && callback.call(this, err);
        }.bind(this)) : void ("function" == typeof callback && callback(new Error("The Web MIDI API is not supported by your browser.")));
      }, WebMidi.prototype.disable = function () {
        if (!this.supported) throw new Error("The Web MIDI API is not supported by your browser.");
        this["interface"] && (this["interface"].onstatechange = void 0), this["interface"] = void 0, this._inputs = [], this._outputs = [], this._resetInterfaceUserHandlers();
      }, WebMidi.prototype.addListener = function (type, listener) {
        if (!this.enabled) throw new Error("WebMidi must be enabled before adding event listeners.");
        if ("function" != typeof listener) throw new TypeError("The 'listener' parameter must be a function.");
        if (!(this._midiInterfaceEvents.indexOf(type) >= 0)) throw new TypeError("The specified event type is not supported.");
        return this._userHandlers[type].push(listener), this;
      }, WebMidi.prototype.hasListener = function (type, listener) {
        if (!this.enabled) throw new Error("WebMidi must be enabled before checking event listeners.");
        if ("function" != typeof listener) throw new TypeError("The 'listener' parameter must be a function.");
        if (!(this._midiInterfaceEvents.indexOf(type) >= 0)) throw new TypeError("The specified event type is not supported.");

        for (var o = 0; o < this._userHandlers[type].length; o++) {
          if (this._userHandlers[type][o] === listener) return !0;
        }

        return !1;
      }, WebMidi.prototype.removeListener = function (type, listener) {
        if (!this.enabled) throw new Error("WebMidi must be enabled before removing event listeners.");
        if (void 0 !== listener && "function" != typeof listener) throw new TypeError("The 'listener' parameter must be a function.");
        if (this._midiInterfaceEvents.indexOf(type) >= 0) {
          if (listener) for (var o = 0; o < this._userHandlers[type].length; o++) {
            this._userHandlers[type][o] === listener && this._userHandlers[type].splice(o, 1);
          } else this._userHandlers[type] = [];
        } else {
          if (void 0 !== type) throw new TypeError("The specified event type is not supported.");

          this._resetInterfaceUserHandlers();
        }
        return this;
      }, WebMidi.prototype.toMIDIChannels = function (channel) {
        var channels;
        return channels = "all" === channel || void 0 === channel ? ["all"] : Array.isArray(channel) ? channel : [channel], channels.indexOf("all") > -1 && (channels = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]), channels.map(function (ch) {
          return parseInt(ch);
        }).filter(function (ch) {
          return ch >= 1 && 16 >= ch;
        });
      }, WebMidi.prototype.getInputById = function (id) {
        if (!this.enabled) throw new Error("WebMidi is not enabled.");

        for (var i = 0; i < this.inputs.length; i++) {
          if (this.inputs[i].id === id) return this.inputs[i];
        }

        return !1;
      }, WebMidi.prototype.getOutputById = function (id) {
        if (!this.enabled) throw new Error("WebMidi is not enabled.");

        for (var i = 0; i < this.outputs.length; i++) {
          if (this.outputs[i].id === id) return this.outputs[i];
        }

        return !1;
      }, WebMidi.prototype.getInputByName = function (name) {
        if (!this.enabled) throw new Error("WebMidi is not enabled.");

        for (var i = 0; i < this.inputs.length; i++) {
          if (~this.inputs[i].name.indexOf(name)) return this.inputs[i];
        }

        return !1;
      }, WebMidi.prototype.getOctave = function (number) {
        return null != number && number >= 0 && 127 >= number ? Math.floor(Math.floor(number) / 12 - 1) + Math.floor(wm.octaveOffset) : void 0;
      }, WebMidi.prototype.getOutputByName = function (name) {
        if (!this.enabled) throw new Error("WebMidi is not enabled.");

        for (var i = 0; i < this.outputs.length; i++) {
          if (~this.outputs[i].name.indexOf(name)) return this.outputs[i];
        }

        return !1;
      }, WebMidi.prototype.guessNoteNumber = function (input) {
        var output = !1;
        if (input && input.toFixed && input >= 0 && 127 >= input ? output = Math.round(input) : parseInt(input) >= 0 && parseInt(input) <= 127 ? output = parseInt(input) : ("string" == typeof input || input instanceof String) && (output = this.noteNameToNumber(input)), output === !1) throw new Error("Invalid input value (" + input + ").");
        return output;
      }, WebMidi.prototype.noteNameToNumber = function (name) {
        "string" != typeof name && (name = "");
        var matches = name.match(/([CDEFGAB])(#{0,2}|b{0,2})(-?\d+)/i);
        if (!matches) throw new RangeError("Invalid note name.");

        var semitones = wm._semitones[matches[1].toUpperCase()],
            octave = parseInt(matches[3]),
            result = 12 * (octave + 1 - Math.floor(wm.octaveOffset)) + semitones;

        if (matches[2].toLowerCase().indexOf("b") > -1 ? result -= matches[2].length : matches[2].toLowerCase().indexOf("#") > -1 && (result += matches[2].length), 0 > result || result > 127) throw new RangeError("Invalid note name or note outside valid range.");
        return result;
      }, WebMidi.prototype._updateInputsAndOutputs = function () {
        this._updateInputs(), this._updateOutputs();
      }, WebMidi.prototype._updateInputs = function () {
        for (var i = 0; i < this._inputs.length; i++) {
          for (var remove = !0, updated = this["interface"].inputs.values(), input = updated.next(); input && !input.done; input = updated.next()) {
            if (this._inputs[i]._midiInput === input.value) {
              remove = !1;
              break;
            }
          }

          remove && this._inputs.splice(i, 1);
        }

        this["interface"] && this["interface"].inputs.forEach(function (nInput) {
          for (var add = !0, j = 0; j < this._inputs.length; j++) {
            this._inputs[j]._midiInput === nInput && (add = !1);
          }

          add && this._inputs.push(new Input(nInput));
        }.bind(this));
      }, WebMidi.prototype._updateOutputs = function () {
        for (var i = 0; i < this._outputs.length; i++) {
          for (var remove = !0, updated = this["interface"].outputs.values(), output = updated.next(); output && !output.done; output = updated.next()) {
            if (this._outputs[i]._midiOutput === output.value) {
              remove = !1;
              break;
            }
          }

          remove && this._outputs.splice(i, 1);
        }

        this["interface"] && this["interface"].outputs.forEach(function (nOutput) {
          for (var add = !0, j = 0; j < this._outputs.length; j++) {
            this._outputs[j]._midiOutput === nOutput && (add = !1);
          }

          add && this._outputs.push(new Output(nOutput));
        }.bind(this));
      }, WebMidi.prototype._onInterfaceStateChange = function (e) {
        this._updateInputsAndOutputs();

        var event = {
          timestamp: e.timeStamp,
          type: e.port.state
        };
        this["interface"] && "connected" === e.port.state ? "output" === e.port.type ? event.port = this.getOutputById(e.port.id) : "input" === e.port.type && (event.port = this.getInputById(e.port.id)) : event.port = {
          connection: "closed",
          id: e.port.id,
          manufacturer: e.port.manufacturer,
          name: e.port.name,
          state: e.port.state,
          type: e.port.type
        }, this._userHandlers[e.port.state].forEach(function (handler) {
          handler(event);
        });
      }, WebMidi.prototype._resetInterfaceUserHandlers = function () {
        for (var i = 0; i < this._midiInterfaceEvents.length; i++) {
          this._userHandlers[this._midiInterfaceEvents[i]] = [];
        }
      }, Input.prototype.addListener = function (type, channel, listener) {
        var that = this;
        if (void 0 === channel && (channel = "all"), Array.isArray(channel) || (channel = [channel]), channel.forEach(function (item) {
          if ("all" !== item && !(item >= 1 && 16 >= item)) throw new RangeError("The 'channel' parameter is invalid.");
        }), "function" != typeof listener) throw new TypeError("The 'listener' parameter must be a function.");
        if (void 0 !== wm.MIDI_SYSTEM_MESSAGES[type]) this._userHandlers.system[type] || (this._userHandlers.system[type] = []), this._userHandlers.system[type].push(listener);else {
          if (void 0 === wm.MIDI_CHANNEL_MESSAGES[type]) throw new TypeError("The specified event type is not supported.");

          if (channel.indexOf("all") > -1) {
            channel = [];

            for (var j = 1; 16 >= j; j++) {
              channel.push(j);
            }
          }

          this._userHandlers.channel[type] || (this._userHandlers.channel[type] = []), channel.forEach(function (ch) {
            that._userHandlers.channel[type][ch] || (that._userHandlers.channel[type][ch] = []), that._userHandlers.channel[type][ch].push(listener);
          });
        }
        return this;
      }, Input.prototype.on = Input.prototype.addListener, Input.prototype.hasListener = function (type, channel, listener) {
        var that = this;
        if ("function" != typeof listener) throw new TypeError("The 'listener' parameter must be a function.");

        if (void 0 === channel && (channel = "all"), channel.constructor !== Array && (channel = [channel]), void 0 !== wm.MIDI_SYSTEM_MESSAGES[type]) {
          for (var o = 0; o < this._userHandlers.system[type].length; o++) {
            if (this._userHandlers.system[type][o] === listener) return !0;
          }
        } else if (void 0 !== wm.MIDI_CHANNEL_MESSAGES[type]) {
          if (channel.indexOf("all") > -1) {
            channel = [];

            for (var j = 1; 16 >= j; j++) {
              channel.push(j);
            }
          }

          return this._userHandlers.channel[type] ? channel.every(function (chNum) {
            var listeners = that._userHandlers.channel[type][chNum];
            return listeners && listeners.indexOf(listener) > -1;
          }) : !1;
        }

        return !1;
      }, Input.prototype.removeListener = function (type, channel, listener) {
        var that = this;
        if (void 0 !== listener && "function" != typeof listener) throw new TypeError("The 'listener' parameter must be a function.");
        if (void 0 === channel && (channel = "all"), channel.constructor !== Array && (channel = [channel]), void 0 !== wm.MIDI_SYSTEM_MESSAGES[type]) {
          if (void 0 === listener) this._userHandlers.system[type] = [];else for (var o = 0; o < this._userHandlers.system[type].length; o++) {
            this._userHandlers.system[type][o] === listener && this._userHandlers.system[type].splice(o, 1);
          }
        } else if (void 0 !== wm.MIDI_CHANNEL_MESSAGES[type]) {
          if (channel.indexOf("all") > -1) {
            channel = [];

            for (var j = 1; 16 >= j; j++) {
              channel.push(j);
            }
          }

          if (!this._userHandlers.channel[type]) return this;
          channel.forEach(function (chNum) {
            var listeners = that._userHandlers.channel[type][chNum];
            if (listeners) if (void 0 === listener) that._userHandlers.channel[type][chNum] = [];else for (var l = 0; l < listeners.length; l++) {
              listeners[l] === listener && listeners.splice(l, 1);
            }
          });
        } else {
          if (void 0 !== type) throw new TypeError("The specified event type is not supported.");

          this._initializeUserHandlers();
        }
        return this;
      }, Input.prototype._initializeUserHandlers = function () {
        for (var prop1 in wm.MIDI_CHANNEL_MESSAGES) {
          wm.MIDI_CHANNEL_MESSAGES.hasOwnProperty(prop1) && (this._userHandlers.channel[prop1] = {});
        }

        for (var prop2 in wm.MIDI_SYSTEM_MESSAGES) {
          wm.MIDI_SYSTEM_MESSAGES.hasOwnProperty(prop2) && (this._userHandlers.system[prop2] = []);
        }
      }, Input.prototype._onMidiMessage = function (e) {
        if (this._userHandlers.system.midimessage.length > 0) {
          var event = {
            target: this,
            data: e.data,
            timestamp: e.timeStamp,
            type: "midimessage"
          };

          this._userHandlers.system.midimessage.forEach(function (callback) {
            callback(event);
          });
        }

        e.data[0] < 240 ? this._parseChannelEvent(e) : e.data[0] <= 255 && this._parseSystemEvent(e);
      }, Input.prototype._parseChannelEvent = function (e) {
        var data1,
            data2,
            command = e.data[0] >> 4,
            channel = (15 & e.data[0]) + 1;
        e.data.length > 1 && (data1 = e.data[1], data2 = e.data.length > 2 ? e.data[2] : void 0);
        var event = {
          target: this,
          data: e.data,
          timestamp: e.timeStamp,
          channel: channel
        };
        command === wm.MIDI_CHANNEL_MESSAGES.noteoff || command === wm.MIDI_CHANNEL_MESSAGES.noteon && 0 === data2 ? (event.type = "noteoff", event.note = {
          number: data1,
          name: wm._notes[data1 % 12],
          octave: wm.getOctave(data1)
        }, event.velocity = data2 / 127, event.rawVelocity = data2) : command === wm.MIDI_CHANNEL_MESSAGES.noteon ? (event.type = "noteon", event.note = {
          number: data1,
          name: wm._notes[data1 % 12],
          octave: wm.getOctave(data1)
        }, event.velocity = data2 / 127, event.rawVelocity = data2) : command === wm.MIDI_CHANNEL_MESSAGES.keyaftertouch ? (event.type = "keyaftertouch", event.note = {
          number: data1,
          name: wm._notes[data1 % 12],
          octave: wm.getOctave(data1)
        }, event.value = data2 / 127) : command === wm.MIDI_CHANNEL_MESSAGES.controlchange && data1 >= 0 && 119 >= data1 ? (event.type = "controlchange", event.controller = {
          number: data1,
          name: this.getCcNameByNumber(data1)
        }, event.value = data2) : command === wm.MIDI_CHANNEL_MESSAGES.channelmode && data1 >= 120 && 127 >= data1 ? (event.type = "channelmode", event.controller = {
          number: data1,
          name: this.getChannelModeByNumber(data1)
        }, event.value = data2) : command === wm.MIDI_CHANNEL_MESSAGES.programchange ? (event.type = "programchange", event.value = data1) : command === wm.MIDI_CHANNEL_MESSAGES.channelaftertouch ? (event.type = "channelaftertouch", event.value = data1 / 127) : command === wm.MIDI_CHANNEL_MESSAGES.pitchbend ? (event.type = "pitchbend", event.value = ((data2 << 7) + data1 - 8192) / 8192) : event.type = "unknownchannelmessage", this._userHandlers.channel[event.type] && this._userHandlers.channel[event.type][channel] && this._userHandlers.channel[event.type][channel].forEach(function (callback) {
          callback(event);
        });
      }, Input.prototype.getCcNameByNumber = function (number) {
        if (number = Math.floor(number), !(number >= 0 && 119 >= number)) throw new RangeError("The control change number must be between 0 and 119.");

        for (var cc in wm.MIDI_CONTROL_CHANGE_MESSAGES) {
          if (wm.MIDI_CONTROL_CHANGE_MESSAGES.hasOwnProperty(cc) && number === wm.MIDI_CONTROL_CHANGE_MESSAGES[cc]) return cc;
        }

        return void 0;
      }, Input.prototype.getChannelModeByNumber = function (number) {
        if (number = Math.floor(number), !(number >= 120 && status <= 127)) throw new RangeError("The control change number must be between 120 and 127.");

        for (var cm in wm.MIDI_CHANNEL_MODE_MESSAGES) {
          if (wm.MIDI_CHANNEL_MODE_MESSAGES.hasOwnProperty(cm) && number === wm.MIDI_CHANNEL_MODE_MESSAGES[cm]) return cm;
        }
      }, Input.prototype._parseSystemEvent = function (e) {
        var command = e.data[0],
            event = {
          target: this,
          data: e.data,
          timestamp: e.timeStamp
        };
        command === wm.MIDI_SYSTEM_MESSAGES.sysex ? event.type = "sysex" : command === wm.MIDI_SYSTEM_MESSAGES.timecode ? event.type = "timecode" : command === wm.MIDI_SYSTEM_MESSAGES.songposition ? event.type = "songposition" : command === wm.MIDI_SYSTEM_MESSAGES.songselect ? (event.type = "songselect", event.song = e.data[1]) : command === wm.MIDI_SYSTEM_MESSAGES.tuningrequest ? event.type = "tuningrequest" : command === wm.MIDI_SYSTEM_MESSAGES.clock ? event.type = "clock" : command === wm.MIDI_SYSTEM_MESSAGES.start ? event.type = "start" : command === wm.MIDI_SYSTEM_MESSAGES["continue"] ? event.type = "continue" : command === wm.MIDI_SYSTEM_MESSAGES.stop ? event.type = "stop" : command === wm.MIDI_SYSTEM_MESSAGES.activesensing ? event.type = "activesensing" : command === wm.MIDI_SYSTEM_MESSAGES.reset ? event.type = "reset" : event.type = "unknownsystemmessage", this._userHandlers.system[event.type] && this._userHandlers.system[event.type].forEach(function (callback) {
          callback(event);
        });
      }, Output.prototype.send = function (status, data, timestamp) {
        if (!(status >= 128 && 255 >= status)) throw new RangeError("The status byte must be an integer between 128 (0x80) and 255 (0xFF).");
        void 0 === data && (data = []), Array.isArray(data) || (data = [data]);
        var message = [];
        return data.forEach(function (item, index) {
          var parsed = Math.floor(item);
          if (!(parsed >= 0 && 255 >= parsed)) throw new RangeError("Data bytes must be integers between 0 (0x00) and 255 (0xFF).");
          message.push(parsed);
        }), this._midiOutput.send([status].concat(message), parseFloat(timestamp) || 0), this;
      }, Output.prototype.sendSysex = function (manufacturer, data, options) {
        if (!wm.sysexEnabled) throw new Error("Sysex message support must first be activated.");
        return options = options || {}, manufacturer = [].concat(manufacturer), data.forEach(function (item) {
          if (0 > item || item > 127) throw new RangeError("The data bytes of a sysex message must be integers between 0 (0x00) and 127 (0x7F).");
        }), data = manufacturer.concat(data, wm.MIDI_SYSTEM_MESSAGES.sysexend), this.send(wm.MIDI_SYSTEM_MESSAGES.sysex, data, this._parseTimeParameter(options.time)), this;
      }, Output.prototype.sendTimecodeQuarterFrame = function (value, options) {
        return options = options || {}, this.send(wm.MIDI_SYSTEM_MESSAGES.timecode, value, this._parseTimeParameter(options.time)), this;
      }, Output.prototype.sendSongPosition = function (value, options) {
        value = Math.floor(value) || 0, options = options || {};
        var msb = value >> 7 & 127,
            lsb = 127 & value;
        return this.send(wm.MIDI_SYSTEM_MESSAGES.songposition, [msb, lsb], this._parseTimeParameter(options.time)), this;
      }, Output.prototype.sendSongSelect = function (value, options) {
        if (value = Math.floor(value), options = options || {}, !(value >= 0 && 127 >= value)) throw new RangeError("The song number must be between 0 and 127.");
        return this.send(wm.MIDI_SYSTEM_MESSAGES.songselect, [value], this._parseTimeParameter(options.time)), this;
      }, Output.prototype.sendTuningRequest = function (options) {
        return options = options || {}, this.send(wm.MIDI_SYSTEM_MESSAGES.tuningrequest, void 0, this._parseTimeParameter(options.time)), this;
      }, Output.prototype.sendClock = function (options) {
        return options = options || {}, this.send(wm.MIDI_SYSTEM_MESSAGES.clock, void 0, this._parseTimeParameter(options.time)), this;
      }, Output.prototype.sendStart = function (options) {
        return options = options || {}, this.send(wm.MIDI_SYSTEM_MESSAGES.start, void 0, this._parseTimeParameter(options.time)), this;
      }, Output.prototype.sendContinue = function (options) {
        return options = options || {}, this.send(wm.MIDI_SYSTEM_MESSAGES["continue"], void 0, this._parseTimeParameter(options.time)), this;
      }, Output.prototype.sendStop = function (options) {
        return options = options || {}, this.send(wm.MIDI_SYSTEM_MESSAGES.stop, void 0, this._parseTimeParameter(options.time)), this;
      }, Output.prototype.sendActiveSensing = function (options) {
        return options = options || {}, this.send(wm.MIDI_SYSTEM_MESSAGES.activesensing, [], this._parseTimeParameter(options.time)), this;
      }, Output.prototype.sendReset = function (options) {
        return options = options || {}, this.send(wm.MIDI_SYSTEM_MESSAGES.reset, void 0, this._parseTimeParameter(options.time)), this;
      }, Output.prototype.stopNote = function (note, channel, options) {
        if ("all" === note) return this.sendChannelMode("allnotesoff", 0, channel, options);
        var nVelocity = 64;
        return options = options || {}, options.rawVelocity ? !isNaN(options.velocity) && options.velocity >= 0 && options.velocity <= 127 && (nVelocity = options.velocity) : !isNaN(options.velocity) && options.velocity >= 0 && options.velocity <= 1 && (nVelocity = 127 * options.velocity), this._convertNoteToArray(note).forEach(function (item) {
          wm.toMIDIChannels(channel).forEach(function (ch) {
            this.send((wm.MIDI_CHANNEL_MESSAGES.noteoff << 4) + (ch - 1), [item, Math.round(nVelocity)], this._parseTimeParameter(options.time));
          }.bind(this));
        }.bind(this)), this;
      }, Output.prototype.playNote = function (note, channel, options) {
        var nVelocity = 64;

        if (options = options || {}, options.rawVelocity ? !isNaN(options.velocity) && options.velocity >= 0 && options.velocity <= 127 && (nVelocity = options.velocity) : !isNaN(options.velocity) && options.velocity >= 0 && options.velocity <= 1 && (nVelocity = 127 * options.velocity), options.time = this._parseTimeParameter(options.time), this._convertNoteToArray(note).forEach(function (item) {
          wm.toMIDIChannels(channel).forEach(function (ch) {
            this.send((wm.MIDI_CHANNEL_MESSAGES.noteon << 4) + (ch - 1), [item, Math.round(nVelocity)], options.time);
          }.bind(this));
        }.bind(this)), !isNaN(options.duration)) {
          options.duration <= 0 && (options.duration = 0);
          var nRelease = 64;
          options.rawVelocity ? !isNaN(options.release) && options.release >= 0 && options.release <= 127 && (nRelease = options.release) : !isNaN(options.release) && options.release >= 0 && options.release <= 1 && (nRelease = 127 * options.release), this._convertNoteToArray(note).forEach(function (item) {
            wm.toMIDIChannels(channel).forEach(function (ch) {
              this.send((wm.MIDI_CHANNEL_MESSAGES.noteoff << 4) + (ch - 1), [item, Math.round(nRelease)], (options.time || wm.time) + options.duration);
            }.bind(this));
          }.bind(this));
        }

        return this;
      }, Output.prototype.sendKeyAftertouch = function (note, channel, pressure, options) {
        var that = this;
        if (options = options || {}, 1 > channel || channel > 16) throw new RangeError("The channel must be between 1 and 16.");
        (isNaN(pressure) || 0 > pressure || pressure > 1) && (pressure = .5);
        var nPressure = Math.round(127 * pressure);
        return this._convertNoteToArray(note).forEach(function (item) {
          wm.toMIDIChannels(channel).forEach(function (ch) {
            that.send((wm.MIDI_CHANNEL_MESSAGES.keyaftertouch << 4) + (ch - 1), [item, nPressure], that._parseTimeParameter(options.time));
          });
        }), this;
      }, Output.prototype.sendControlChange = function (controller, value, channel, options) {
        if (options = options || {}, "string" == typeof controller) {
          if (controller = wm.MIDI_CONTROL_CHANGE_MESSAGES[controller], !controller) throw new TypeError("Invalid controller name.");
        } else if (controller = Math.floor(controller), !(controller >= 0 && 119 >= controller)) throw new RangeError("Controller numbers must be between 0 and 119.");

        if (value = Math.floor(value) || 0, !(value >= 0 && 127 >= value)) throw new RangeError("Controller value must be between 0 and 127.");
        return wm.toMIDIChannels(channel).forEach(function (ch) {
          this.send((wm.MIDI_CHANNEL_MESSAGES.controlchange << 4) + (ch - 1), [controller, value], this._parseTimeParameter(options.time));
        }.bind(this)), this;
      }, Output.prototype._selectRegisteredParameter = function (parameter, channel, time) {
        var that = this;
        if (parameter[0] = Math.floor(parameter[0]), !(parameter[0] >= 0 && parameter[0] <= 127)) throw new RangeError("The control65 value must be between 0 and 127");
        if (parameter[1] = Math.floor(parameter[1]), !(parameter[1] >= 0 && parameter[1] <= 127)) throw new RangeError("The control64 value must be between 0 and 127");
        return wm.toMIDIChannels(channel).forEach(function (ch) {
          that.sendControlChange(101, parameter[0], channel, {
            time: time
          }), that.sendControlChange(100, parameter[1], channel, {
            time: time
          });
        }), this;
      }, Output.prototype._selectNonRegisteredParameter = function (parameter, channel, time) {
        var that = this;
        if (parameter[0] = Math.floor(parameter[0]), !(parameter[0] >= 0 && parameter[0] <= 127)) throw new RangeError("The control63 value must be between 0 and 127");
        if (parameter[1] = Math.floor(parameter[1]), !(parameter[1] >= 0 && parameter[1] <= 127)) throw new RangeError("The control62 value must be between 0 and 127");
        return wm.toMIDIChannels(channel).forEach(function (ch) {
          that.sendControlChange(99, parameter[0], channel, {
            time: time
          }), that.sendControlChange(98, parameter[1], channel, {
            time: time
          });
        }), this;
      }, Output.prototype._setCurrentRegisteredParameter = function (data, channel, time) {
        var that = this;
        if (data = [].concat(data), data[0] = Math.floor(data[0]), !(data[0] >= 0 && data[0] <= 127)) throw new RangeError("The msb value must be between 0 and 127");
        return wm.toMIDIChannels(channel).forEach(function (ch) {
          that.sendControlChange(6, data[0], channel, {
            time: time
          });
        }), data[1] = Math.floor(data[1]), data[1] >= 0 && data[1] <= 127 && wm.toMIDIChannels(channel).forEach(function (ch) {
          that.sendControlChange(38, data[1], channel, {
            time: time
          });
        }), this;
      }, Output.prototype._deselectRegisteredParameter = function (channel, time) {
        var that = this;
        return wm.toMIDIChannels(channel).forEach(function (ch) {
          that.sendControlChange(101, 127, channel, {
            time: time
          }), that.sendControlChange(100, 127, channel, {
            time: time
          });
        }), this;
      }, Output.prototype.setRegisteredParameter = function (parameter, data, channel, options) {
        var that = this;

        if (options = options || {}, !Array.isArray(parameter)) {
          if (!wm.MIDI_REGISTERED_PARAMETER[parameter]) throw new Error("The specified parameter is not available.");
          parameter = wm.MIDI_REGISTERED_PARAMETER[parameter];
        }

        return wm.toMIDIChannels(channel).forEach(function (ch) {
          that._selectRegisteredParameter(parameter, channel, options.time), that._setCurrentRegisteredParameter(data, channel, options.time), that._deselectRegisteredParameter(channel, options.time);
        }), this;
      }, Output.prototype.setNonRegisteredParameter = function (parameter, data, channel, options) {
        var that = this;
        if (options = options || {}, !(parameter[0] >= 0 && parameter[0] <= 127 && parameter[1] >= 0 && parameter[1] <= 127)) throw new Error("Position 0 and 1 of the 2-position parameter array must both be between 0 and 127.");
        return data = [].concat(data), wm.toMIDIChannels(channel).forEach(function (ch) {
          that._selectNonRegisteredParameter(parameter, channel, options.time), that._setCurrentRegisteredParameter(data, channel, options.time), that._deselectRegisteredParameter(channel, options.time);
        }), this;
      }, Output.prototype.incrementRegisteredParameter = function (parameter, channel, options) {
        var that = this;

        if (options = options || {}, !Array.isArray(parameter)) {
          if (!wm.MIDI_REGISTERED_PARAMETER[parameter]) throw new Error("The specified parameter is not available.");
          parameter = wm.MIDI_REGISTERED_PARAMETER[parameter];
        }

        return wm.toMIDIChannels(channel).forEach(function (ch) {
          that._selectRegisteredParameter(parameter, channel, options.time), that.sendControlChange(96, 0, channel, {
            time: options.time
          }), that._deselectRegisteredParameter(channel, options.time);
        }), this;
      }, Output.prototype.decrementRegisteredParameter = function (parameter, channel, options) {
        if (options = options || {}, !Array.isArray(parameter)) {
          if (!wm.MIDI_REGISTERED_PARAMETER[parameter]) throw new TypeError("The specified parameter is not available.");
          parameter = wm.MIDI_REGISTERED_PARAMETER[parameter];
        }

        return wm.toMIDIChannels(channel).forEach(function (ch) {
          this._selectRegisteredParameter(parameter, channel, options.time), this.sendControlChange(97, 0, channel, {
            time: options.time
          }), this._deselectRegisteredParameter(channel, options.time);
        }.bind(this)), this;
      }, Output.prototype.setPitchBendRange = function (semitones, cents, channel, options) {
        var that = this;
        if (options = options || {}, semitones = Math.floor(semitones) || 0, !(semitones >= 0 && 127 >= semitones)) throw new RangeError("The semitones value must be between 0 and 127");
        if (cents = Math.floor(cents) || 0, !(cents >= 0 && 127 >= cents)) throw new RangeError("The cents value must be between 0 and 127");
        return wm.toMIDIChannels(channel).forEach(function (ch) {
          that.setRegisteredParameter("pitchbendrange", [semitones, cents], channel, {
            time: options.time
          });
        }), this;
      }, Output.prototype.setModulationRange = function (semitones, cents, channel, options) {
        var that = this;
        if (options = options || {}, semitones = Math.floor(semitones) || 0, !(semitones >= 0 && 127 >= semitones)) throw new RangeError("The semitones value must be between 0 and 127");
        if (cents = Math.floor(cents) || 0, !(cents >= 0 && 127 >= cents)) throw new RangeError("The cents value must be between 0 and 127");
        return wm.toMIDIChannels(channel).forEach(function (ch) {
          that.setRegisteredParameter("modulationrange", [semitones, cents], channel, {
            time: options.time
          });
        }), this;
      }, Output.prototype.setMasterTuning = function (value, channel, options) {
        var that = this;
        if (options = options || {}, value = parseFloat(value) || 0, -65 >= value || value >= 64) throw new RangeError("The value must be a decimal number larger than -65 and smaller than 64.");
        var coarse = Math.floor(value) + 64,
            fine = value - Math.floor(value);
        fine = Math.round((fine + 1) / 2 * 16383);
        var msb = fine >> 7 & 127,
            lsb = 127 & fine;
        return wm.toMIDIChannels(channel).forEach(function (ch) {
          that.setRegisteredParameter("channelcoarsetuning", coarse, channel, {
            time: options.time
          }), that.setRegisteredParameter("channelfinetuning", [msb, lsb], channel, {
            time: options.time
          });
        }), this;
      }, Output.prototype.setTuningProgram = function (value, channel, options) {
        var that = this;
        if (options = options || {}, value = Math.floor(value), !(value >= 0 && 127 >= value)) throw new RangeError("The program value must be between 0 and 127");
        return wm.toMIDIChannels(channel).forEach(function (ch) {
          that.setRegisteredParameter("tuningprogram", value, channel, {
            time: options.time
          });
        }), this;
      }, Output.prototype.setTuningBank = function (value, channel, options) {
        var that = this;
        if (options = options || {}, value = Math.floor(value) || 0, !(value >= 0 && 127 >= value)) throw new RangeError("The bank value must be between 0 and 127");
        return wm.toMIDIChannels(channel).forEach(function (ch) {
          that.setRegisteredParameter("tuningbank", value, channel, {
            time: options.time
          });
        }), this;
      }, Output.prototype.sendChannelMode = function (command, value, channel, options) {
        if (options = options || {}, "string" == typeof command) {
          if (command = wm.MIDI_CHANNEL_MODE_MESSAGES[command], !command) throw new TypeError("Invalid channel mode message name.");
        } else if (command = Math.floor(command), !(command >= 120 && 127 >= command)) throw new RangeError("Channel mode numerical identifiers must be between 120 and 127.");

        if (value = Math.floor(value) || 0, 0 > value || value > 127) throw new RangeError("Value must be an integer between 0 and 127.");
        return wm.toMIDIChannels(channel).forEach(function (ch) {
          this.send((wm.MIDI_CHANNEL_MESSAGES.channelmode << 4) + (ch - 1), [command, value], this._parseTimeParameter(options.time));
        }.bind(this)), this;
      }, Output.prototype.sendProgramChange = function (program, channel, options) {
        var that = this;
        if (options = options || {}, program = Math.floor(program), isNaN(program) || 0 > program || program > 127) throw new RangeError("Program numbers must be between 0 and 127.");
        return wm.toMIDIChannels(channel).forEach(function (ch) {
          that.send((wm.MIDI_CHANNEL_MESSAGES.programchange << 4) + (ch - 1), [program], that._parseTimeParameter(options.time));
        }), this;
      }, Output.prototype.sendChannelAftertouch = function (pressure, channel, options) {
        var that = this;
        options = options || {}, pressure = parseFloat(pressure), (isNaN(pressure) || 0 > pressure || pressure > 1) && (pressure = .5);
        var nPressure = Math.round(127 * pressure);
        return wm.toMIDIChannels(channel).forEach(function (ch) {
          that.send((wm.MIDI_CHANNEL_MESSAGES.channelaftertouch << 4) + (ch - 1), [nPressure], that._parseTimeParameter(options.time));
        }), this;
      }, Output.prototype.sendPitchBend = function (bend, channel, options) {
        var that = this;
        if (options = options || {}, isNaN(bend) || -1 > bend || bend > 1) throw new RangeError("Pitch bend value must be between -1 and 1.");
        var nLevel = Math.round((bend + 1) / 2 * 16383),
            msb = nLevel >> 7 & 127,
            lsb = 127 & nLevel;
        return wm.toMIDIChannels(channel).forEach(function (ch) {
          that.send((wm.MIDI_CHANNEL_MESSAGES.pitchbend << 4) + (ch - 1), [lsb, msb], that._parseTimeParameter(options.time));
        }), this;
      }, Output.prototype._parseTimeParameter = function (time) {
        var parsed, value;
        return "string" == typeof time && "+" === time.substring(0, 1) ? (parsed = parseFloat(time), parsed && parsed > 0 && (value = wm.time + parsed)) : (parsed = parseFloat(time), parsed > wm.time && (value = parsed)), value;
      }, Output.prototype._convertNoteToArray = function (note) {
        var notes = [];
        return Array.isArray(note) || (note = [note]), note.forEach(function (item) {
          notes.push(wm.guessNoteNumber(item));
        }), notes;
      }, "function" == typeof define && "object" == _typeof2(define.amd) ? define([], function () {
        return wm;
      }) : "undefined" != typeof module && module.exports ? module.exports = wm : scope.WebMidi || (scope.WebMidi = wm);
    }(this);
  }, {}]
}, {}, [2]);